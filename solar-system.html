<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solar System Portfolio</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Space+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    overflow: hidden;
    background: #000;
    font-family: 'Outfit', sans-serif;
    color: #fff;
    cursor: crosshair;
  }
  canvas { display: block; }

  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #title-card {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 20;
    pointer-events: none;
    opacity: 1;
    transition: opacity 0.8s ease;
  }
  #title-card.hidden { opacity: 0; }
  #title-card h1 {
    font-size: 4rem;
    font-weight: 800;
    letter-spacing: -2px;
    background: linear-gradient(135deg, #fff 0%, #ffd080 50%, #ff6040 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: none;
    margin-bottom: 0.5rem;
  }
  #title-card p {
    font-family: 'Space Mono', monospace;
    font-size: 0.85rem;
    color: rgba(255,200,150,0.7);
    letter-spacing: 4px;
    text-transform: uppercase;
  }

  #planet-info {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none;
  }
  #planet-info.visible { opacity: 1; pointer-events: auto; }
  #planet-info h2 {
    font-size: 2.5rem;
    font-weight: 800;
    letter-spacing: -1px;
    margin-bottom: 0.5rem;
  }
  #planet-info .subtitle {
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    color: rgba(255,255,255,0.5);
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 1rem;
  }
  #planet-info .description {
    max-width: 500px;
    margin: 0 auto;
    font-size: 0.95rem;
    line-height: 1.7;
    color: rgba(255,255,255,0.75);
    font-weight: 300;
  }

  #nav-hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    color: rgba(255,255,255,0.3);
    letter-spacing: 3px;
    text-transform: uppercase;
    z-index: 20;
  }

  #back-btn {
    position: fixed;
    top: 30px;
    left: 30px;
    z-index: 30;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.6);
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 4px;
    opacity: 0;
    transition: opacity 0.5s ease, background 0.3s;
    pointer-events: none;
  }
  #back-btn.visible { opacity: 1; pointer-events: auto; }
  #back-btn:hover { background: rgba(255,255,255,0.1); }

  .vignette {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
    pointer-events: none;
    z-index: 5;
  }

  .lens-flare {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 300px;
    height: 300px;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(255,200,100,0.15) 0%, transparent 70%);
    pointer-events: none;
    z-index: 4;
    border-radius: 50%;
  }
</style>
</head>
<body>

<div class="vignette"></div>
<div class="lens-flare" id="lensFlare"></div>

<div id="title-card">
  <h1>ALEX CHEN</h1>
  <p>Creative Developer &bull; Designer</p>
</div>

<div id="planet-info">
  <h2 id="info-title"></h2>
  <div class="subtitle" id="info-subtitle"></div>
  <div class="description" id="info-desc"></div>
</div>

<button id="back-btn">&#8592; Back to orbit</button>
<div id="nav-hint">Click a planet to explore</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.prepend(renderer.domElement);

// Camera
camera.position.set(0, 12, 28);
camera.lookAt(0, 0, 0);

let cameraTarget = { x: 0, y: 12, z: 28 };
let cameraLookTarget = { x: 0, y: 0, z: 0 };
let selectedPlanet = null;
let animating = false;

// Stars
const starsGeo = new THREE.BufferGeometry();
const starsCount = 6000;
const starsPos = new Float32Array(starsCount * 3);
const starsSizes = new Float32Array(starsCount);
for (let i = 0; i < starsCount; i++) {
  const r = 200 + Math.random() * 800;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  starsPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
  starsPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
  starsPos[i*3+2] = r * Math.cos(phi);
  starsSizes[i] = Math.random() * 2 + 0.5;
}
starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
starsGeo.setAttribute('size', new THREE.BufferAttribute(starsSizes, 1));

const starsMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 } },
  vertexShader: `
    attribute float size;
    uniform float time;
    varying float vAlpha;
    void main() {
      vAlpha = 0.4 + 0.6 * abs(sin(time * 0.5 + position.x * 0.01));
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * (200.0 / -mvPos.z);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    varying float vAlpha;
    void main() {
      float d = length(gl_PointCoord - 0.5);
      if (d > 0.5) discard;
      float alpha = smoothstep(0.5, 0.0, d) * vAlpha;
      gl_FragColor = vec4(1.0, 0.95, 0.9, alpha);
    }
  `,
  transparent: true,
  depthWrite: false
});
scene.add(new THREE.Points(starsGeo, starsMat));

// Sun
const sunGeo = new THREE.SphereGeometry(2.5, 64, 64);
const sunMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 } },
  vertexShader: `
    varying vec3 vNormal;
    varying vec2 vUv;
    void main() {
      vNormal = normal;
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    varying vec3 vNormal;
    varying vec2 vUv;
    void main() {
      float pulse = 0.8 + 0.2 * sin(time * 2.0 + vUv.y * 10.0);
      vec3 core = vec3(1.0, 0.85, 0.4) * pulse;
      vec3 edge = vec3(1.0, 0.4, 0.1);
      float rim = 1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0));
      vec3 col = mix(core, edge, rim * rim);
      gl_FragColor = vec4(col, 1.0);
    }
  `
});
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);

// Sun glow
const glowGeo = new THREE.SphereGeometry(4.5, 32, 32);
const glowMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 } },
  vertexShader: `
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    varying vec3 vNormal;
    void main() {
      float intensity = pow(0.6 - dot(vNormal, vec3(0,0,1)), 2.0);
      float pulse = 0.8 + 0.2 * sin(time * 1.5);
      gl_FragColor = vec4(1.0, 0.6, 0.2, intensity * 0.4 * pulse);
    }
  `,
  transparent: true,
  side: THREE.BackSide,
  depthWrite: false
});
scene.add(new THREE.Mesh(glowGeo, glowMat));

// Sun light
const sunLight = new THREE.PointLight(0xffcc88, 2, 100);
scene.add(sunLight);
scene.add(new THREE.AmbientLight(0x222244, 0.3));

// Planet data
const planetData = [
  {
    name: 'About',
    subtitle: 'WHO I AM',
    desc: 'A creative developer passionate about blending code and design. 5+ years building immersive web experiences, interactive installations, and design systems that push boundaries.',
    radius: 1.0,
    orbitRadius: 7,
    speed: 0.4,
    color1: [0.2, 0.5, 1.0],
    color2: [0.1, 0.2, 0.6],
    emissive: [0.05, 0.1, 0.3]
  },
  {
    name: 'Projects',
    subtitle: 'SELECTED WORK',
    desc: 'From WebGL experiments to full-stack applications. Each project is a journey — exploring new technologies, solving complex problems, and crafting memorable experiences.',
    radius: 1.4,
    orbitRadius: 12,
    speed: 0.25,
    color1: [0.9, 0.4, 0.2],
    color2: [0.6, 0.15, 0.05],
    emissive: [0.2, 0.05, 0.0]
  },
  {
    name: 'Skills',
    subtitle: 'TECHNOLOGIES',
    desc: 'Three.js, React, WebGL, GLSL Shaders, Node.js, TypeScript, Blender, Figma, Creative Coding, Motion Design, and an endless curiosity for learning more.',
    radius: 0.8,
    orbitRadius: 17,
    speed: 0.18,
    color1: [0.3, 0.9, 0.5],
    color2: [0.05, 0.4, 0.15],
    emissive: [0.02, 0.15, 0.05]
  },
  {
    name: 'Experience',
    subtitle: 'CAREER PATH',
    desc: 'Led creative development at Studio Flux, freelanced for global brands, and contributed to open-source tools used by thousands of developers worldwide.',
    radius: 1.1,
    orbitRadius: 22,
    speed: 0.12,
    color1: [0.8, 0.3, 0.9],
    color2: [0.3, 0.05, 0.5],
    emissive: [0.1, 0.02, 0.15]
  },
  {
    name: 'Contact',
    subtitle: 'SAY HELLO',
    desc: 'Ready to collaborate on something amazing? Whether it\'s a creative project, a full-time role, or just a chat about shaders — I\'d love to hear from you.',
    radius: 0.7,
    orbitRadius: 26,
    speed: 0.08,
    color1: [1.0, 0.8, 0.3],
    color2: [0.6, 0.4, 0.05],
    emissive: [0.2, 0.15, 0.02]
  }
];

const planets = [];
const orbitLines = [];

planetData.forEach((data, i) => {
  // Orbit ring
  const orbitGeo = new THREE.RingGeometry(data.orbitRadius - 0.02, data.orbitRadius + 0.02, 128);
  const orbitMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0.06, side: THREE.DoubleSide
  });
  const orbitMesh = new THREE.Mesh(orbitGeo, orbitMat);
  orbitMesh.rotation.x = -Math.PI / 2;
  scene.add(orbitMesh);
  orbitLines.push(orbitMesh);

  // Planet
  const geo = new THREE.SphereGeometry(data.radius, 48, 48);
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      color1: { value: new THREE.Vector3(...data.color1) },
      color2: { value: new THREE.Vector3(...data.color2) },
      emissiveColor: { value: new THREE.Vector3(...data.emissive) },
      sunPos: { value: new THREE.Vector3(0, 0, 0) },
      hovered: { value: 0.0 }
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vWorldPos;
      varying vec2 vUv;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 emissiveColor;
      uniform vec3 sunPos;
      uniform float hovered;
      varying vec3 vNormal;
      varying vec3 vWorldPos;
      varying vec2 vUv;

      float noise(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
      }

      void main() {
        vec3 lightDir = normalize(sunPos - vWorldPos);
        float diff = max(dot(vNormal, lightDir), 0.0);
        diff = diff * 0.7 + 0.3;

        float n = noise(vUv * 8.0 + time * 0.1);
        vec3 baseCol = mix(color1, color2, n * 0.5 + vUv.y * 0.5);
        vec3 col = baseCol * diff + emissiveColor;

        float rim = 1.0 - max(dot(vNormal, normalize(cameraPosition - vWorldPos)), 0.0);
        col += color1 * pow(rim, 3.0) * 0.5;
        col += color1 * hovered * 0.3;

        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  const planet = new THREE.Mesh(geo, mat);
  planet.userData = { ...data, index: i, angle: (i / planetData.length) * Math.PI * 2 };
  scene.add(planet);
  planets.push(planet);

  // Planet glow
  const pGlowGeo = new THREE.SphereGeometry(data.radius * 1.6, 32, 32);
  const pGlowMat = new THREE.ShaderMaterial({
    uniforms: {
      color: { value: new THREE.Vector3(...data.color1) },
      hovered: { value: 0.0 }
    },
    vertexShader: `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 color;
      uniform float hovered;
      varying vec3 vNormal;
      void main() {
        float intensity = pow(0.5 - dot(vNormal, vec3(0,0,1)), 2.0);
        float a = intensity * (0.15 + hovered * 0.25);
        gl_FragColor = vec4(color, a);
      }
    `,
    transparent: true, side: THREE.BackSide, depthWrite: false
  });
  const pGlow = new THREE.Mesh(pGlowGeo, pGlowMat);
  planet.add(pGlow);
  planet.userData.glowMat = pGlowMat;

  // Label (rendered as sprite)
  const canvas = document.createElement('canvas');
  canvas.width = 512; canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.font = '700 48px Outfit';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.fillText(data.name, 256, 70);
  const tex = new THREE.CanvasTexture(canvas);
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.8 });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(4, 1, 1);
  sprite.position.y = data.radius + 1.5;
  planet.add(sprite);
});

// Particle trails
const trailCount = 2000;
const trailGeo = new THREE.BufferGeometry();
const trailPos = new Float32Array(trailCount * 3);
const trailAlpha = new Float32Array(trailCount);
for (let i = 0; i < trailCount; i++) {
  const pIdx = Math.floor(Math.random() * planets.length);
  const p = planetData[pIdx];
  const a = Math.random() * Math.PI * 2;
  const r = p.orbitRadius + (Math.random() - 0.5) * 1.5;
  trailPos[i*3] = Math.cos(a) * r;
  trailPos[i*3+1] = (Math.random() - 0.5) * 0.5;
  trailPos[i*3+2] = Math.sin(a) * r;
  trailAlpha[i] = Math.random();
}
trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
trailGeo.setAttribute('alpha', new THREE.BufferAttribute(trailAlpha, 1));
const trailMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 } },
  vertexShader: `
    attribute float alpha;
    varying float vAlpha;
    uniform float time;
    void main() {
      vAlpha = alpha * (0.3 + 0.3 * sin(time + alpha * 6.28));
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = 1.5 * (100.0 / -mvPos.z);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    varying float vAlpha;
    void main() {
      float d = length(gl_PointCoord - 0.5);
      if (d > 0.5) discard;
      gl_FragColor = vec4(1.0, 0.8, 0.5, smoothstep(0.5, 0.0, d) * vAlpha);
    }
  `,
  transparent: true, depthWrite: false
});
scene.add(new THREE.Points(trailGeo, trailMat));

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredPlanet = null;

document.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  // Subtle parallax
  if (!selectedPlanet) {
    const px = mouse.x * 1.5;
    const py = mouse.y * 1.0;
    cameraTarget.x = px;
    cameraTarget.y = 12 + py;
  }

  // Lens flare follow
  const lf = document.getElementById('lensFlare');
  lf.style.left = (50 - mouse.x * 5) + '%';
  lf.style.top = (50 + mouse.y * 5) + '%';
});

document.addEventListener('click', () => {
  if (animating) return;

  if (hoveredPlanet && !selectedPlanet) {
    // Fly to planet
    selectedPlanet = hoveredPlanet;
    animating = true;
    const p = selectedPlanet;
    const dir = new THREE.Vector3().subVectors(p.position, new THREE.Vector3(0,0,0)).normalize();
    cameraTarget = {
      x: p.position.x + dir.x * (p.userData.radius * 4),
      y: p.position.y + 2,
      z: p.position.z + dir.z * (p.userData.radius * 4)
    };
    cameraLookTarget = { x: p.position.x, y: p.position.y, z: p.position.z };

    document.getElementById('title-card').classList.add('hidden');
    document.getElementById('back-btn').classList.add('visible');
    document.getElementById('info-title').textContent = p.userData.name;
    document.getElementById('info-subtitle').textContent = p.userData.subtitle;
    document.getElementById('info-desc').textContent = p.userData.desc;
    setTimeout(() => {
      document.getElementById('planet-info').classList.add('visible');
      animating = false;
    }, 800);
  }
});

document.getElementById('back-btn').addEventListener('click', () => {
  if (animating) return;
  animating = true;
  selectedPlanet = null;
  cameraTarget = { x: 0, y: 12, z: 28 };
  cameraLookTarget = { x: 0, y: 0, z: 0 };
  document.getElementById('planet-info').classList.remove('visible');
  document.getElementById('back-btn').classList.remove('visible');
  setTimeout(() => {
    document.getElementById('title-card').classList.remove('hidden');
    animating = false;
  }, 800);
});

// Animation
const clock = new THREE.Clock();
const currentLook = new THREE.Vector3(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Update uniforms
  sunMat.uniforms.time.value = t;
  glowMat.uniforms.time.value = t;
  starsMat.uniforms.time.value = t;
  trailMat.uniforms.time.value = t;

  // Orbit planets
  planets.forEach((planet, i) => {
    const d = planet.userData;
    d.angle += d.speed * 0.005;
    planet.position.x = Math.cos(d.angle) * d.orbitRadius;
    planet.position.z = Math.sin(d.angle) * d.orbitRadius;
    planet.position.y = Math.sin(d.angle * 2 + i) * 0.3;
    planet.rotation.y += 0.005;
    planet.material.uniforms.time.value = t;
  });

  // Hover detection
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(planets);
  const newHovered = intersects.length > 0 ? intersects[0].object : null;

  if (newHovered !== hoveredPlanet) {
    if (hoveredPlanet) {
      hoveredPlanet.material.uniforms.hovered.value = 0;
      hoveredPlanet.userData.glowMat.uniforms.hovered.value = 0;
    }
    hoveredPlanet = newHovered;
    if (hoveredPlanet) {
      hoveredPlanet.material.uniforms.hovered.value = 1;
      hoveredPlanet.userData.glowMat.uniforms.hovered.value = 1;
    }
  }
  document.body.style.cursor = hoveredPlanet ? 'pointer' : 'crosshair';

  // Smooth camera
  camera.position.x += (cameraTarget.x - camera.position.x) * 0.03;
  camera.position.y += (cameraTarget.y - camera.position.y) * 0.03;
  camera.position.z += (cameraTarget.z - camera.position.z) * 0.03;

  currentLook.x += (cameraLookTarget.x - currentLook.x) * 0.03;
  currentLook.y += (cameraLookTarget.y - currentLook.y) * 0.03;
  currentLook.z += (cameraLookTarget.z - currentLook.z) * 0.03;
  camera.lookAt(currentLook);

  // If tracking selected planet
  if (selectedPlanet) {
    const p = selectedPlanet;
    const dir = new THREE.Vector3().subVectors(p.position, new THREE.Vector3(0,0,0)).normalize();
    cameraTarget.x = p.position.x + dir.x * (p.userData.radius * 5);
    cameraTarget.y = p.position.y + 2;
    cameraTarget.z = p.position.z + dir.z * (p.userData.radius * 5);
    cameraLookTarget.x = p.position.x;
    cameraLookTarget.y = p.position.y;
    cameraLookTarget.z = p.position.z;
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
