<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Space Station</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; }
  canvas { display: block; }

  #overlay {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    cursor: pointer;
    font-family: 'Courier New', monospace;
  }

  #overlay .inner {
    text-align: center;
    color: #aaa;
  }

  #overlay h1 {
    font-size: 2.4rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: #ccc;
    margin-bottom: 1rem;
    font-weight: 300;
  }

  #overlay p {
    font-size: 0.9rem;
    color: #777;
    margin-bottom: 0.4rem;
  }

  #overlay .click-hint {
    margin-top: 2rem;
    font-size: 1rem;
    color: #999;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 16px; height: 16px;
    z-index: 5;
    pointer-events: none;
    display: none;
  }
  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(200,200,200,0.4);
  }
  #crosshair::before {
    width: 1px; height: 16px;
    left: 50%; top: 0;
    transform: translateX(-50%);
  }
  #crosshair::after {
    width: 16px; height: 1px;
    top: 50%; left: 0;
    transform: translateY(-50%);
  }

  #info {
    position: fixed;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    color: rgba(180,180,180,0.3);
    font-family: 'Courier New', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    z-index: 5;
    pointer-events: none;
    display: none;
    transition: opacity 3s;
  }
</style>
</head>
<body>

<div id="overlay">
  <div class="inner">
    <h1>The Grey Room</h1>
    <p>WASD / Arrow Keys — Move</p>
    <p>Mouse — Look Around</p>
    <p>Shift — Sprint</p>
    <div class="click-hint">[ click to enter ]</div>
  </div>
</div>

<div id="crosshair"></div>
<div id="info">ESC to release cursor</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(() => {
  // --- Scene Setup ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x1a1a2a, 1, 30);

  const camera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 1.7, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;
  renderer.autoClear = false;
  document.body.appendChild(renderer.domElement);

  // --- Room Geometry ---
  const ROOM_SIZE = 8;
  const HALF = ROOM_SIZE / 2;
  const ROOM_HEIGHT = 4;
  const HALF_H = ROOM_HEIGHT / 2;

  // Textured materials for the walls/floor/ceiling
  function makeWallMaterial(color) {
    return new THREE.MeshStandardMaterial({
      color,
      roughness: 0.92,
      metalness: 0.02,
      side: THREE.BackSide
    });
  }

  // Floor with subtle grid
  const floorCanvas = document.createElement('canvas');
  floorCanvas.width = 512; floorCanvas.height = 512;
  const fctx = floorCanvas.getContext('2d');
  fctx.fillStyle = '#3a3a3a';
  fctx.fillRect(0, 0, 512, 512);
  fctx.strokeStyle = '#444';
  fctx.lineWidth = 1;
  for (let i = 0; i <= 512; i += 64) {
    fctx.beginPath(); fctx.moveTo(i, 0); fctx.lineTo(i, 512); fctx.stroke();
    fctx.beginPath(); fctx.moveTo(0, i); fctx.lineTo(512, i); fctx.stroke();
  }
  const floorTex = new THREE.CanvasTexture(floorCanvas);
  floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
  floorTex.repeat.set(4, 4);

  const floorMat = new THREE.MeshStandardMaterial({
    map: floorTex,
    roughness: 0.85,
    metalness: 0.05,
  });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Ceiling
  const ceilMat = new THREE.MeshStandardMaterial({ color: 0x505050, roughness: 0.95, metalness: 0.0 });
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE), ceilMat);
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = ROOM_HEIGHT;
  ceiling.receiveShadow = true;
  scene.add(ceiling);

  // Walls
  const wallColor = 0x555555;
  const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.9, metalness: 0.02 });

  // Front wall — full solid wall
  const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE, ROOM_HEIGHT), wallMat);
  frontWall.position.set(0, HALF_H, HALF);
  frontWall.rotation.set(0, Math.PI, 0);
  frontWall.receiveShadow = true;
  scene.add(frontWall);

  // --- Space Window wraps: left side (back half) → back wall → right side (back half) ---
  // The window extends across 3 wall segments with a consistent margin from floor/ceiling.
  // Side windows go from z = -HALF to z = 0 (half the wall length).

  const winMargin = 0.6;
  const winH = ROOM_HEIGHT - winMargin * 2;
  const sideWinLen = HALF;   // half the wall = 6 units on each side

  // Helper: create a wall shape with a rectangular window hole
  function makeWallWithHole(wallW, wallH, holeW, holeH) {
    const s = new THREE.Shape();
    s.moveTo(-wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, -wallH / 2);
    const h = new THREE.Path();
    h.moveTo(-holeW / 2, -holeH / 2);
    h.lineTo(holeW / 2, -holeH / 2);
    h.lineTo(holeW / 2, holeH / 2);
    h.lineTo(-holeW / 2, holeH / 2);
    h.lineTo(-holeW / 2, -holeH / 2);
    s.holes.push(h);
    return new THREE.ShapeGeometry(s);
  }

  const winWallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9, metalness: 0.02 });

  // Back wall — full width window (no side margins, flush to corners)
  const backWinW = ROOM_SIZE - winMargin * 2;
  const backWallGeo = makeWallWithHole(ROOM_SIZE, ROOM_HEIGHT, backWinW, winH);
  const backWall = new THREE.Mesh(backWallGeo, winWallMat);
  backWall.position.set(0, HALF_H, -HALF);
  backWall.receiveShadow = true;
  scene.add(backWall);

  // Left wall — split into two halves:
  //   Back half (z: -HALF to 0) has a window hole
  //   Front half (z: 0 to HALF) is solid
  const sideWinW = sideWinLen - winMargin; // window width on side walls (margin only at the front edge)
  const leftBackGeo = makeWallWithHole(sideWinLen, ROOM_HEIGHT, sideWinW, winH);
  const leftBack = new THREE.Mesh(leftBackGeo, winWallMat);
  leftBack.position.set(-HALF, HALF_H, -HALF / 2);
  leftBack.rotation.set(0, Math.PI / 2, 0);
  leftBack.receiveShadow = true;
  scene.add(leftBack);

  const leftFront = new THREE.Mesh(new THREE.PlaneGeometry(sideWinLen, ROOM_HEIGHT), wallMat);
  leftFront.position.set(-HALF, HALF_H, HALF / 2);
  leftFront.rotation.set(0, Math.PI / 2, 0);
  leftFront.receiveShadow = true;
  scene.add(leftFront);

  // Right wall — same split
  const rightBackGeo = makeWallWithHole(sideWinLen, ROOM_HEIGHT, sideWinW, winH);
  const rightBack = new THREE.Mesh(rightBackGeo, winWallMat);
  rightBack.position.set(HALF, HALF_H, -HALF / 2);
  rightBack.rotation.set(0, -Math.PI / 2, 0);
  rightBack.receiveShadow = true;
  scene.add(rightBack);

  const rightFront = new THREE.Mesh(new THREE.PlaneGeometry(sideWinLen, ROOM_HEIGHT), wallMat);
  rightFront.position.set(HALF, HALF_H, HALF / 2);
  rightFront.rotation.set(0, -Math.PI / 2, 0);
  rightFront.receiveShadow = true;
  scene.add(rightFront);

  // --- Space Skybox Scene ---
  // A completely separate scene rendered at infinity (follows camera rotation only).
  const spaceScene = new THREE.Scene();
  const spaceCamera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 1000);

  // Giant sphere with space texture on the inside
  const spaceCanvas = document.createElement('canvas');
  spaceCanvas.width = 4096;
  spaceCanvas.height = 2048;
  const sctx = spaceCanvas.getContext('2d');

  // Deep space background
  sctx.fillStyle = '#000005';
  sctx.fillRect(0, 0, 4096, 2048);

  // Nebula clouds
  function drawNebula(cx, cy, radius, r, g, b, alpha) {
    const grad = sctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
    grad.addColorStop(0, `rgba(${r},${g},${b},${alpha})`);
    grad.addColorStop(0.3, `rgba(${r},${g},${b},${alpha * 0.6})`);
    grad.addColorStop(0.6, `rgba(${r},${g},${b},${alpha * 0.2})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    sctx.fillStyle = grad;
    sctx.fillRect(0, 0, 4096, 2048);
  }

  drawNebula(800, 600, 500, 60, 20, 120, 0.3);
  drawNebula(3000, 400, 600, 20, 50, 140, 0.22);
  drawNebula(2000, 1400, 700, 100, 30, 60, 0.18);
  drawNebula(3400, 1300, 400, 30, 80, 100, 0.15);
  drawNebula(600, 1500, 350, 80, 40, 120, 0.12);
  drawNebula(1600, 500, 450, 40, 30, 100, 0.2);

  // Stars
  function drawStars(count, minSize, maxSize, minAlpha, maxAlpha) {
    for (let i = 0; i < count; i++) {
      const x = Math.random() * 4096;
      const y = Math.random() * 2048;
      const size = minSize + Math.random() * (maxSize - minSize);
      const alpha = minAlpha + Math.random() * (maxAlpha - minAlpha);
      const temp = Math.random();
      let r = 255, g = 255, b = 255;
      if (temp < 0.15) { r = 180; g = 200; b = 255; }
      else if (temp < 0.25) { r = 255; g = 220; b = 180; }
      else if (temp < 0.3) { r = 255; g = 180; b = 160; }
      sctx.beginPath();
      sctx.arc(x, y, size, 0, Math.PI * 2);
      sctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      sctx.fill();
      if (size > 1.8) {
        const glow = sctx.createRadialGradient(x, y, 0, x, y, size * 5);
        glow.addColorStop(0, `rgba(${r},${g},${b},${alpha * 0.3})`);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        sctx.fillStyle = glow;
        sctx.fillRect(x - size * 5, y - size * 5, size * 10, size * 10);
      }
    }
  }

  drawStars(4000, 0.3, 1.0, 0.3, 0.8);
  drawStars(800, 0.8, 1.8, 0.6, 1.0);
  drawStars(120, 1.5, 3.0, 0.8, 1.0);

  // Planet — draw on the canvas at a position that maps to the -Z direction
  // On an equirectangular map, -Z is at the center (x=2048, y=1024)
  const planetX = 2300, planetY = 1100, planetR = 150;
  sctx.save();
  sctx.beginPath();
  sctx.arc(planetX, planetY, planetR, 0, Math.PI * 2);
  sctx.clip();
  const planetGrad = sctx.createLinearGradient(planetX - planetR, planetY, planetX + planetR, planetY);
  planetGrad.addColorStop(0, '#2a4a6a');
  planetGrad.addColorStop(0.3, '#3a6a8a');
  planetGrad.addColorStop(0.6, '#2a5a7a');
  planetGrad.addColorStop(1, '#1a3a5a');
  sctx.fillStyle = planetGrad;
  sctx.fillRect(planetX - planetR, planetY - planetR, planetR * 2, planetR * 2);
  sctx.globalAlpha = 0.15;
  for (let i = 0; i < 10; i++) {
    const bandY = planetY - planetR + (planetR * 2 / 10) * i;
    sctx.fillStyle = i % 2 === 0 ? '#4a8aaa' : '#2a5a7a';
    sctx.fillRect(planetX - planetR, bandY, planetR * 2, planetR * 2 / 10);
  }
  sctx.globalAlpha = 1.0;
  const shadowGrad = sctx.createLinearGradient(planetX - planetR * 0.3, planetY, planetX + planetR, planetY);
  shadowGrad.addColorStop(0, 'rgba(0,0,0,0)');
  shadowGrad.addColorStop(0.5, 'rgba(0,0,0,0.3)');
  shadowGrad.addColorStop(1, 'rgba(0,0,0,0.85)');
  sctx.fillStyle = shadowGrad;
  sctx.fillRect(planetX - planetR, planetY - planetR, planetR * 2, planetR * 2);
  sctx.restore();
  // Atmosphere glow
  const atmoGrad = sctx.createRadialGradient(planetX, planetY, planetR * 0.95, planetX, planetY, planetR * 1.2);
  atmoGrad.addColorStop(0, 'rgba(100,180,255,0)');
  atmoGrad.addColorStop(0.5, 'rgba(100,180,255,0.06)');
  atmoGrad.addColorStop(1, 'rgba(100,180,255,0)');
  sctx.fillStyle = atmoGrad;
  sctx.beginPath();
  sctx.arc(planetX, planetY, planetR * 1.2, 0, Math.PI * 2);
  sctx.fill();

  // Small moon
  const moonX = 1700, moonY = 700, moonR = 45;
  sctx.beginPath();
  sctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
  const moonGrad = sctx.createRadialGradient(moonX - 10, moonY - 10, 0, moonX, moonY, moonR);
  moonGrad.addColorStop(0, '#8a7a6a');
  moonGrad.addColorStop(1, '#3a3530');
  sctx.fillStyle = moonGrad;
  sctx.fill();

  // Distant galaxy
  sctx.save();
  sctx.translate(1900, 500);
  sctx.rotate(0.4);
  sctx.scale(1, 0.3);
  const galaxyGrad = sctx.createRadialGradient(0, 0, 0, 0, 0, 140);
  galaxyGrad.addColorStop(0, 'rgba(200,180,255,0.22)');
  galaxyGrad.addColorStop(0.3, 'rgba(160,140,220,0.1)');
  galaxyGrad.addColorStop(1, 'rgba(0,0,0,0)');
  sctx.fillStyle = galaxyGrad;
  sctx.fillRect(-140, -140, 280, 280);
  sctx.restore();

  const spaceTex = new THREE.CanvasTexture(spaceCanvas);

  // Sky sphere — large sphere with the space texture on the inside
  const skyGeo = new THREE.SphereGeometry(500, 64, 32);
  const skyMat = new THREE.MeshBasicMaterial({
    map: spaceTex,
    side: THREE.BackSide,
    depthWrite: false,
  });
  const skySphere = new THREE.Mesh(skyGeo, skyMat);
  spaceScene.add(skySphere);

  // --- Window frame pieces (dark metal frame wrapping all 3 walls) ---
  const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4, metalness: 0.6 });
  const frameDepth = 0.15;
  const frameThick = 0.12;

  // Back wall frames — horizontal bars
  function addBackFrameH(y) {
    const geo = new THREE.BoxGeometry(backWinW + frameThick * 2, frameThick, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.position.set(0, y, -HALF + frameDepth / 2);
    mesh.castShadow = true;
    scene.add(mesh);
  }
  addBackFrameH(winMargin);
  addBackFrameH(ROOM_HEIGHT - winMargin);
  addBackFrameH(HALF_H);

  // Back wall frames — vertical dividers
  function addBackFrameV(x) {
    const geo = new THREE.BoxGeometry(frameThick, winH + frameThick * 2, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.position.set(x, HALF_H, -HALF + frameDepth / 2);
    mesh.castShadow = true;
    scene.add(mesh);
  }
  addBackFrameV(-backWinW / 6);
  addBackFrameV(backWinW / 6);

  // Left side wall frames — horizontal bars
  function addSideFrameH(wallX, y, len, rotY) {
    const geo = new THREE.BoxGeometry(len, frameThick, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    // Position at the side wall, offset inward by frameDepth/2
    const inset = frameDepth / 2;
    const sign = wallX > 0 ? -1 : 1;
    mesh.position.set(wallX + sign * inset, y, -HALF / 2);
    mesh.rotation.set(0, rotY, 0);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Left wall horizontal frames
  addSideFrameH(-HALF, winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(-HALF, ROOM_HEIGHT - winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(-HALF, HALF_H, sideWinW + frameThick, Math.PI / 2);

  // Right wall horizontal frames
  addSideFrameH(HALF, winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(HALF, ROOM_HEIGHT - winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(HALF, HALF_H, sideWinW + frameThick, Math.PI / 2);

  // Side wall vertical dividers
  function addSideFrameV(wallX, z, rotY) {
    const geo = new THREE.BoxGeometry(frameThick, winH + frameThick * 2, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    const inset = frameDepth / 2;
    const sign = wallX > 0 ? -1 : 1;
    mesh.position.set(wallX + sign * inset, HALF_H, z);
    mesh.rotation.set(0, rotY, 0);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Left wall — front edge frame + center divider
  addSideFrameV(-HALF, -winMargin, Math.PI / 2);        // front edge (where window ends)
  addSideFrameV(-HALF, -HALF / 2, Math.PI / 2);         // center divider

  // Right wall — front edge frame + center divider
  addSideFrameV(HALF, -winMargin, Math.PI / 2);
  addSideFrameV(HALF, -HALF / 2, Math.PI / 2);

  // Corner vertical posts where back wall meets side walls
  const cornerPostGeo = new THREE.BoxGeometry(frameThick, winH + frameThick * 2, frameThick);
  [-1, 1].forEach(sign => {
    const post = new THREE.Mesh(cornerPostGeo, frameMat);
    post.position.set(sign * (HALF - frameThick / 2), HALF_H, -HALF + frameThick / 2);
    post.castShadow = true;
    scene.add(post);
  });

  // --- Window lighting ---
  // Blue light spill from the back window
  const spaceLight = new THREE.PointLight(0x4466aa, 0.5, 12);
  spaceLight.position.set(0, HALF_H, -HALF + 1);
  scene.add(spaceLight);

  const spaceSpot = new THREE.SpotLight(0x334466, 0.3, 10, Math.PI / 3, 0.5);
  spaceSpot.position.set(0, ROOM_HEIGHT - 1, -HALF + 0.5);
  spaceSpot.target.position.set(0, 0, -HALF + 3);
  scene.add(spaceSpot);
  scene.add(spaceSpot.target);

  // Side window light spill
  const leftWinLight = new THREE.PointLight(0x3355aa, 0.35, 10);
  leftWinLight.position.set(-HALF + 1, HALF_H, -HALF / 2);
  scene.add(leftWinLight);

  const rightWinLight = new THREE.PointLight(0x3355aa, 0.35, 10);
  rightWinLight.position.set(HALF - 1, HALF_H, -HALF / 2);
  scene.add(rightWinLight);

  // --- Edge Lines (subtle) ---
  const edgeMat = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3 });
  const edges = [
    // floor edges
    [[-HALF,0,-HALF],[HALF,0,-HALF]],
    [[HALF,0,-HALF],[HALF,0,HALF]],
    [[HALF,0,HALF],[-HALF,0,HALF]],
    [[-HALF,0,HALF],[-HALF,0,-HALF]],
    // ceiling edges
    [[-HALF,ROOM_HEIGHT,-HALF],[HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,ROOM_HEIGHT,-HALF],[HALF,ROOM_HEIGHT,HALF]],
    [[HALF,ROOM_HEIGHT,HALF],[-HALF,ROOM_HEIGHT,HALF]],
    [[-HALF,ROOM_HEIGHT,HALF],[-HALF,ROOM_HEIGHT,-HALF]],
    // verticals
    [[-HALF,0,-HALF],[-HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,0,-HALF],[HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,0,HALF],[HALF,ROOM_HEIGHT,HALF]],
    [[-HALF,0,HALF],[-HALF,ROOM_HEIGHT,HALF]],
  ];
  edges.forEach(([a, b]) => {
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(...a), new THREE.Vector3(...b)]);
    scene.add(new THREE.Line(geo, edgeMat));
  });

  // --- Lighting ---
  // Overhead point light
  const pointLight = new THREE.PointLight(0xffeedd, 1.4, 50, 1.5);
  pointLight.position.set(0, ROOM_HEIGHT - 0.5, 0);
  pointLight.castShadow = true;
  pointLight.shadow.mapSize.set(1024, 1024);
  scene.add(pointLight);

  // Light fixture visual
  const bulbGeo = new THREE.SphereGeometry(0.15, 16, 16);
  const bulbMat = new THREE.MeshBasicMaterial({ color: 0x998a70 });
  const bulb = new THREE.Mesh(bulbGeo, bulbMat);
  bulb.position.copy(pointLight.position);
  scene.add(bulb);

  // Dim ambient
  scene.add(new THREE.AmbientLight(0x888899, 0.12));

  // Secondary fill light
  const fillLight = new THREE.PointLight(0xaabbcc, 0.15, 15);
  fillLight.position.set(-3, 1, 3);
  scene.add(fillLight);

  // --- L-Shape Desk (along back window wall + left side window wall) ---
  const deskY = 0.75;
  const deskThick = 0.06;
  const deskD = 0.95;          // depth (away from wall)
  const deskMargin = 0.3;     // gap from side walls

  const deskMat = new THREE.MeshStandardMaterial({ color: 0x111114, roughness: 0.5, metalness: 0.35 });
  const deskPanelMat = new THREE.MeshStandardMaterial({ color: 0x0e0e12, roughness: 0.45, metalness: 0.4 });
  const deskLegMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1e, roughness: 0.4, metalness: 0.5 });

  // --- Back section (along z = -HALF, spans nearly wall to wall) ---
  const backDeskW = ROOM_SIZE - deskMargin * 2;
  const backDeskZ = -HALF + deskD / 2;

  // Desktop surface
  const backTop = new THREE.Mesh(new THREE.BoxGeometry(backDeskW, deskThick, deskD), deskMat);
  backTop.position.set(0, deskY, backDeskZ);
  backTop.castShadow = true; backTop.receiveShadow = true;
  scene.add(backTop);

  // Front panel
  const backPanel = new THREE.Mesh(new THREE.BoxGeometry(backDeskW, deskY - 0.05, 0.04), deskPanelMat);
  backPanel.position.set(0, deskY / 2, backDeskZ + deskD / 2);
  backPanel.castShadow = true; backPanel.receiveShadow = true;
  scene.add(backPanel);

  // Legs — 4 evenly spaced
  const backLegGeo = new THREE.BoxGeometry(0.06, deskY - 0.05, 0.06);
  [-backDeskW / 2 + 0.15, -backDeskW / 6, backDeskW / 6, backDeskW / 2 - 0.15].forEach(x => {
    const leg = new THREE.Mesh(backLegGeo, deskLegMat);
    leg.position.set(x, (deskY - 0.05) / 2, backDeskZ - deskD / 2 + 0.1);
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // --- Left section (along x = -HALF, from back wall to z = 0 where window ends) ---
  const sideDeskLen = HALF - deskD / 2 - deskMargin;  // from back section edge to z = 0 minus margin
  const sideDeskX = -HALF + deskD / 2;
  const sideDeskZ = -HALF + deskD + sideDeskLen / 2;

  // Desktop surface
  const sideTop = new THREE.Mesh(new THREE.BoxGeometry(deskD, deskThick, sideDeskLen), deskMat);
  sideTop.position.set(sideDeskX, deskY, sideDeskZ);
  sideTop.castShadow = true; sideTop.receiveShadow = true;
  scene.add(sideTop);

  // Front panel (faces +X, toward room center)
  const sidePanel = new THREE.Mesh(new THREE.BoxGeometry(0.04, deskY - 0.05, sideDeskLen), deskPanelMat);
  sidePanel.position.set(sideDeskX + deskD / 2, deskY / 2, sideDeskZ);
  sidePanel.castShadow = true; sidePanel.receiveShadow = true;
  scene.add(sidePanel);

  // End panel (caps the open end at z ~ 0)
  const endPanel = new THREE.Mesh(new THREE.BoxGeometry(deskD, deskY - 0.05, 0.04), deskPanelMat);
  endPanel.position.set(sideDeskX, deskY / 2, sideDeskZ + sideDeskLen / 2);
  endPanel.castShadow = true; endPanel.receiveShadow = true;
  scene.add(endPanel);

  // Legs — 2 along the side section
  const sideLegGeo = new THREE.BoxGeometry(0.06, deskY - 0.05, 0.06);
  [sideDeskZ - sideDeskLen / 2 + 0.15, sideDeskZ + sideDeskLen / 2 - 0.15].forEach(z => {
    const leg = new THREE.Mesh(sideLegGeo, deskLegMat);
    leg.position.set(sideDeskX + deskD / 2 - 0.1, (deskY - 0.05) / 2, z);
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // --- Wooden Nightstand (front-right corner, opposite windows) ---
  const nsX = HALF - 0.45, nsZ = HALF - 0.45;
  const nsW = 0.5, nsD = 0.5, nsH = 0.55;
  const nsThick = 0.04;

  // Wood material
  const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B5E3C, roughness: 0.75, metalness: 0.05 });
  const woodDarkMat = new THREE.MeshStandardMaterial({ color: 0x6B4226, roughness: 0.8, metalness: 0.05 });

  // Tabletop
  const nsTop = new THREE.Mesh(new THREE.BoxGeometry(nsW, nsThick, nsD), woodMat);
  nsTop.position.set(nsX, nsH, nsZ);
  nsTop.castShadow = true; nsTop.receiveShadow = true;
  scene.add(nsTop);

  // Four legs
  const legH = nsH - nsThick / 2;
  const legThick = 0.05;
  const legGeo = new THREE.BoxGeometry(legThick, legH, legThick);
  [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
    const leg = new THREE.Mesh(legGeo, woodDarkMat);
    leg.position.set(
      nsX + sx * (nsW / 2 - legThick / 2),
      legH / 2,
      nsZ + sz * (nsD / 2 - legThick / 2)
    );
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // Bottom shelf
  const shelfY = 0.12;
  const nsShelf = new THREE.Mesh(new THREE.BoxGeometry(nsW - 0.06, nsThick * 0.7, nsD - 0.06), woodMat);
  nsShelf.position.set(nsX, shelfY, nsZ);
  nsShelf.castShadow = true; nsShelf.receiveShadow = true;
  scene.add(nsShelf);

  // --- Cozy Orange Lamp (on top of nightstand) ---
  const lampBaseY = nsH + nsThick / 2;

  // Lamp base — small dark wood disc
  const lampBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.08, 0.025, 20),
    woodDarkMat
  );
  lampBase.position.set(nsX, lampBaseY + 0.0125, nsZ);
  lampBase.castShadow = true;
  scene.add(lampBase);

  // Lamp pole — thin brass-ish stem
  const poleMat = new THREE.MeshStandardMaterial({ color: 0xAA8844, roughness: 0.35, metalness: 0.6 });
  const lampPole = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.25, 10), poleMat);
  lampPole.position.set(nsX, lampBaseY + 0.15, nsZ);
  lampPole.castShadow = true;
  scene.add(lampPole);

  // Neon bulb — hot emissive sphere (no shade)
  const lampBulbMat = new THREE.MeshStandardMaterial({
    color: 0xFF6600,
    emissive: 0xFF6600,
    emissiveIntensity: 3.0,
    roughness: 0.05,
    metalness: 0.8,
  });
  const lampBulb = new THREE.Mesh(new THREE.SphereGeometry(0.06, 24, 24), lampBulbMat);
  lampBulb.position.set(nsX, lampBaseY + 0.34, nsZ);
  scene.add(lampBulb);

  // Neon glow layers — stacked transparent spheres for bloom
  [
    { radius: 0.10, color: 0xFFAA44, opacity: 0.4 },
    { radius: 0.20, color: 0xFF6600, opacity: 0.2 },
    { radius: 0.38, color: 0xFF5500, opacity: 0.09 },
    { radius: 0.65, color: 0xFF4400, opacity: 0.035 },
    { radius: 1.0,  color: 0xFF3300, opacity: 0.015 },
  ].forEach(g => {
    const mat = new THREE.MeshBasicMaterial({ color: g.color, transparent: true, opacity: g.opacity, depthWrite: false });
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(g.radius, 24, 24), mat);
    mesh.position.set(nsX, lampBaseY + 0.34, nsZ);
    scene.add(mesh);
  });

  // Primary neon point light — intense
  const orangeLight = new THREE.PointLight(0xFF5500, 1.8, 10, 1.5);
  orangeLight.position.set(nsX, lampBaseY + 0.34, nsZ);
  orangeLight.castShadow = true;
  orangeLight.shadow.mapSize.set(512, 512);
  scene.add(orangeLight);

  // Secondary fill — wider neon wash
  const orangeFill = new THREE.PointLight(0xFF4400, 0.6, 16, 2);
  orangeFill.position.set(nsX, lampBaseY + 0.34, nsZ);
  scene.add(orangeFill);

  // --- Player Controls ---
  const keys = {};
  let yaw = 0, pitch = 0;
  let locked = false;
  const SPEED = 4;
  const SPRINT_MULT = 1.8;
  const SENSITIVITY = 0.002;
  const PLAYER_RADIUS = 0.4;
  const EYE_HEIGHT = 1.7;
  const BOUND = HALF - PLAYER_RADIUS;

  // Head bob
  let bobTime = 0;
  const BOB_SPEED = 10;
  const BOB_AMOUNT = 0.04;

  document.addEventListener('keydown', e => keys[e.code] = true);
  document.addEventListener('keyup', e => keys[e.code] = false);

  document.addEventListener('mousemove', e => {
    if (!locked) return;
    yaw -= e.movementX * SENSITIVITY;
    pitch -= e.movementY * SENSITIVITY;
    pitch = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, pitch));
  });

  // Pointer lock
  const overlay = document.getElementById('overlay');
  const crosshair = document.getElementById('crosshair');
  const info = document.getElementById('info');

  overlay.addEventListener('click', () => {
    renderer.domElement.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', () => {
    locked = document.pointerLockElement === renderer.domElement;
    overlay.style.display = locked ? 'none' : 'flex';
    crosshair.style.display = locked ? 'block' : 'none';
    info.style.display = locked ? 'block' : 'none';
  });

  // Footstep audio context (subtle)
  let audioCtx;
  let lastStepTime = 0;

  function playStep() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 60 + Math.random() * 30;
    gain.gain.setValueAtTime(0.03, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.12);
  }

  // --- Game Loop ---
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);

    if (locked) {
      const sprint = keys['ShiftLeft'] || keys['ShiftRight'] ? SPRINT_MULT : 1;
      const speed = SPEED * sprint * dt;

      const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

      let moving = false;
      const move = new THREE.Vector3();

      if (keys['KeyW'] || keys['ArrowUp']) { move.add(forward); moving = true; }
      if (keys['KeyS'] || keys['ArrowDown']) { move.sub(forward); moving = true; }
      if (keys['KeyD'] || keys['ArrowRight']) { move.add(right); moving = true; }
      if (keys['KeyA'] || keys['ArrowLeft']) { move.sub(right); moving = true; }

      if (moving) {
        move.normalize().multiplyScalar(speed);
        camera.position.x = Math.max(-BOUND, Math.min(BOUND, camera.position.x + move.x));
        camera.position.z = Math.max(-BOUND, Math.min(BOUND, camera.position.z + move.z));

        // Head bob
        bobTime += dt * BOB_SPEED * sprint;
        camera.position.y = EYE_HEIGHT + Math.sin(bobTime) * BOB_AMOUNT;

        // Footstep sounds
        const stepInterval = sprint > 1 ? 0.3 : 0.5;
        if (clock.elapsedTime - lastStepTime > stepInterval) {
          playStep();
          lastStepTime = clock.elapsedTime;
        }
      } else {
        // Smoothly return to eye height
        camera.position.y += (EYE_HEIGHT - camera.position.y) * 0.1;
      }

      // Apply rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }

    // Subtle light flicker
    pointLight.intensity = 0.6 + Math.sin(clock.elapsedTime * 3) * 0.02;

    // --- Two-pass render: skybox first, then room on top ---
    // Pass 1: Render space skybox (rotation only — no position, so it's at infinity)
    spaceCamera.quaternion.copy(camera.quaternion);

    renderer.clear(true, true, true);
    renderer.render(spaceScene, spaceCamera);

    // Pass 2: Render the room on top. Clear only the depth buffer so
    // room geometry writes over the skybox, but the hole in the back wall
    // lets the skybox pixels show through.
    renderer.clearDepth();
    renderer.render(scene, camera);
  }

  animate();

  // --- Resize ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    spaceCamera.aspect = window.innerWidth / window.innerHeight;
    spaceCamera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>
