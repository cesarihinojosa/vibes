<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Space Station</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; }
  canvas { display: block; }

  #overlay {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    cursor: pointer;
    font-family: 'Courier New', monospace;
  }

  #overlay .inner {
    text-align: center;
    color: #aaa;
  }

  #overlay h1 {
    font-size: 2.4rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: #ccc;
    margin-bottom: 1rem;
    font-weight: 300;
  }

  #overlay p {
    font-size: 0.9rem;
    color: #777;
    margin-bottom: 0.4rem;
  }

  #overlay .click-hint {
    margin-top: 2rem;
    font-size: 1rem;
    color: #999;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 16px; height: 16px;
    z-index: 5;
    pointer-events: none;
    display: none;
  }
  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(200,200,200,0.4);
  }
  #crosshair::before {
    width: 1px; height: 16px;
    left: 50%; top: 0;
    transform: translateX(-50%);
  }
  #crosshair::after {
    width: 16px; height: 1px;
    top: 50%; left: 0;
    transform: translateY(-50%);
  }
  #crosshair.hover-green::before, #crosshair.hover-green::after {
    background: rgba(100,255,140,0.9);
  }
  #crosshair.hover-green {
    width: 22px; height: 22px;
    border: 1.5px solid rgba(100,255,140,0.7);
    border-radius: 50%;
  }
  #crosshair.hover-blue::before, #crosshair.hover-blue::after {
    background: rgba(60,180,255,0.9);
  }
  #crosshair.hover-blue {
    width: 22px; height: 22px;
    border: 1.5px solid rgba(60,180,255,0.7);
    border-radius: 50%;
  }
  #crosshair.hover-pink::before, #crosshair.hover-pink::after {
    background: rgba(255,80,180,0.9);
  }
  #crosshair.hover-pink {
    width: 22px; height: 22px;
    border: 1.5px solid rgba(255,80,180,0.7);
    border-radius: 50%;
  }

  #modal-backdrop {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 15;
  }

  #about-modal {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 420px;
    background: rgba(13, 17, 23, 0.92);
    border: 1px solid rgba(60, 180, 255, 0.35);
    border-radius: 8px;
    padding: 30px 35px;
    z-index: 20;
    font-family: 'Courier New', monospace;
    color: rgba(180, 210, 240, 0.85);
    font-size: 14px;
    line-height: 1.7;
    backdrop-filter: blur(8px);
  }
  #about-modal h2 {
    margin: 0 0 16px 0;
    font-size: 22px;
    color: rgba(60, 180, 255, 0.9);
  }
  #about-modal .close-hint {
    margin-top: 20px;
    font-size: 11px;
    color: rgba(60, 180, 255, 0.3);
    text-align: center;
  }

  .paper-modal {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 420px;
    background: rgba(245, 240, 230, 0.95);
    border: 1px solid rgba(180, 160, 120, 0.5);
    border-radius: 4px;
    padding: 35px 40px;
    z-index: 20;
    font-family: 'Courier New', monospace;
    color: rgba(40, 40, 35, 0.85);
    font-size: 13px;
    line-height: 1.8;
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  }
  .paper-modal h2 {
    margin: 0 0 16px 0;
    font-size: 18px;
    color: rgba(50, 50, 45, 0.9);
    font-weight: bold;
  }
  .paper-modal .close-hint {
    margin-top: 20px;
    font-size: 11px;
    color: rgba(140, 120, 80, 0.5);
    text-align: center;
  }
  #cv-modal {
    width: 520px;
    max-height: 80vh;
    overflow-y: auto;
    line-height: 1.6;
  }
  #cv-modal h2 {
    text-align: center;
    font-size: 20px;
    margin-bottom: 4px;
  }
  #cv-modal .cv-subtitle {
    text-align: center;
    font-size: 11px;
    color: rgba(80, 75, 60, 0.7);
    margin-bottom: 18px;
  }
  #cv-modal h3 {
    font-size: 14px;
    color: rgba(50, 50, 45, 0.9);
    margin: 18px 0 8px 0;
    padding-bottom: 4px;
    border-bottom: 1px solid rgba(140, 120, 80, 0.3);
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }
  #cv-modal .cv-entry {
    margin-bottom: 12px;
  }
  #cv-modal .cv-entry .cv-role {
    font-weight: bold;
    font-size: 13px;
    color: rgba(40, 40, 35, 0.9);
  }
  #cv-modal .cv-entry .cv-place {
    font-size: 12px;
    color: rgba(80, 75, 60, 0.8);
  }
  #cv-modal .cv-entry .cv-date {
    font-size: 11px;
    color: rgba(120, 110, 85, 0.7);
  }
  #cv-modal .cv-entry .cv-desc {
    font-size: 12px;
    color: rgba(60, 55, 45, 0.75);
    margin-top: 2px;
  }
  #cv-modal .cv-skills {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
  }
  #cv-modal .cv-skills span {
    font-size: 11px;
    padding: 3px 8px;
    background: rgba(60, 50, 30, 0.08);
    border: 1px solid rgba(140, 120, 80, 0.25);
    border-radius: 3px;
    color: rgba(50, 50, 45, 0.8);
  }

  .paper-modal .modal-link {
    display: inline-block;
    margin-top: 16px;
    padding: 8px 20px;
    background: rgba(60, 50, 30, 0.1);
    border: 1px solid rgba(140, 120, 80, 0.5);
    border-radius: 4px;
    color: rgba(50, 50, 45, 0.9);
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-decoration: none;
    cursor: pointer;
    transition: background 0.2s, border-color 0.2s;
  }
  .paper-modal .modal-link:hover {
    background: rgba(60, 50, 30, 0.2);
    border-color: rgba(140, 120, 80, 0.8);
  }

  #crosshair.hover-paper {
    width: 22px; height: 22px;
    border: 1.5px solid rgba(210,190,140,0.8);
    border-radius: 50%;
  }

  #linkedin-modal {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 420px;
    background: rgba(23, 10, 16, 0.92);
    border: 1px solid rgba(255, 80, 180, 0.35);
    border-radius: 8px;
    padding: 30px 35px;
    z-index: 20;
    font-family: 'Courier New', monospace;
    color: rgba(240, 180, 210, 0.85);
    font-size: 14px;
    line-height: 1.7;
    backdrop-filter: blur(8px);
  }
  #linkedin-modal h2 {
    margin: 0 0 16px 0;
    font-size: 22px;
    color: rgba(255, 80, 180, 0.9);
  }
  #linkedin-modal .modal-link {
    display: inline-block;
    margin-top: 16px;
    padding: 8px 20px;
    background: rgba(255, 80, 180, 0.15);
    border: 1px solid rgba(255, 80, 180, 0.5);
    border-radius: 4px;
    color: rgba(255, 80, 180, 0.9);
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-decoration: none;
    cursor: pointer;
    transition: background 0.2s, border-color 0.2s;
  }
  #linkedin-modal .modal-link:hover {
    background: rgba(255, 80, 180, 0.3);
    border-color: rgba(255, 80, 180, 0.8);
  }
  #linkedin-modal .close-hint {
    margin-top: 20px;
    font-size: 11px;
    color: rgba(255, 80, 180, 0.3);
    text-align: center;
  }

  #github-modal {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 420px;
    background: rgba(13, 17, 23, 0.92);
    border: 1px solid rgba(100, 255, 140, 0.35);
    border-radius: 8px;
    padding: 30px 35px;
    z-index: 20;
    font-family: 'Courier New', monospace;
    color: rgba(180, 240, 200, 0.85);
    font-size: 14px;
    line-height: 1.7;
    backdrop-filter: blur(8px);
  }
  #github-modal h2 {
    margin: 0 0 16px 0;
    font-size: 22px;
    color: rgba(100, 255, 140, 0.9);
  }
  #github-modal .modal-link {
    display: inline-block;
    margin-top: 16px;
    padding: 8px 20px;
    background: rgba(100, 255, 140, 0.15);
    border: 1px solid rgba(100, 255, 140, 0.5);
    border-radius: 4px;
    color: rgba(100, 255, 140, 0.9);
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-decoration: none;
    cursor: pointer;
    transition: background 0.2s, border-color 0.2s;
  }
  #github-modal .modal-link:hover {
    background: rgba(100, 255, 140, 0.3);
    border-color: rgba(100, 255, 140, 0.8);
  }
  #github-modal .close-hint {
    margin-top: 20px;
    font-size: 11px;
    color: rgba(100, 255, 140, 0.3);
    text-align: center;
  }

  #info {
    position: fixed;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    color: rgba(180,180,180,0.3);
    font-family: 'Courier New', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    z-index: 5;
    pointer-events: none;
    display: none;
    transition: opacity 3s;
  }
</style>
</head>
<body>

<div id="overlay">
  <div class="inner">
    <div class="click-hint">[ click anywhere ]</div>
  </div>
</div>

<div id="crosshair"></div>
<div id="info">ESC to release cursor</div>

<div id="modal-backdrop"></div>

<div id="cv-modal" class="paper-modal">
  <h2>Cesar Hinojosa</h2>
  <div class="cv-subtitle">San Antonio, TX | Software Engineer</div>

  <h3>Experience</h3>
  <div class="cv-entry">
    <div class="cv-role">Associate Software Engineer</div>
    <div class="cv-place">Northrop Grumman — San Antonio, TX</div>
    <div class="cv-date">Oct 2024 — Present</div>
    <div class="cv-desc">Lead developer on a production system delivering a containerized Kotlin/Python application deployed to Kubernetes. Implemented automated integration testing with pytest, designed RESTful APIs in Kotlin (Spring Boot), and led CI/CD adoption across the program.</div>
  </div>
  <div class="cv-entry">
    <div class="cv-role">Cyber Software Engineer Intern</div>
    <div class="cv-place">Northrop Grumman — San Antonio, TX</div>
    <div class="cv-date">May 2023 — July 2023</div>
    <div class="cv-desc">Developed and maintained embedded software in C++, supporting builds, testing, and deployment in Linux and virtualized hardware environments.</div>
  </div>
  <div class="cv-entry">
    <div class="cv-role">Game Developer Intern</div>
    <div class="cv-place">Resilience Inc. — Remote</div>
    <div class="cv-date">Oct 2022 — May 2023</div>
    <div class="cv-desc">Designed and developed an educational PC game in C# and Unity aimed at teaching children task prioritization through interactive gameplay.</div>
  </div>

  <h3>Education</h3>
  <div class="cv-entry">
    <div class="cv-role">B.S. Computer Science</div>
    <div class="cv-place">University of Texas at San Antonio</div>
    <div class="cv-date">Oct 2020 — May 2024 | GPA: 3.9/4.0</div>
  </div>

  <h3>Skills</h3>
  <div class="cv-skills">
    <span>Go</span>
    <span>C</span>
    <span>C++</span>
    <span>Kotlin</span>
    <span>Java</span>
    <span>Python</span>
    <span>C#</span>
    <span>JavaScript</span>
    <span>SQL</span>
    <span>Bash</span>
    <span>Docker</span>
    <span>Kubernetes</span>
    <span>CI/CD</span>
    <span>Linux</span>
    <span>Spring Boot</span>
    <span>Flask</span>
    <span>Unity</span>
    <span>Pytest</span>
  </div>

  <h3>Projects</h3>
  <div class="cv-skills">
    <span>POSIX Shell (Go)</span>
    <span>Digital Bookshelf (Flask, AWS)</span>
    <span>Educational Pizza Game (Unity, C#)</span>
    <span>Inventory System (Python, SQL)</span>
    <span>Train an AI (Python, RL)</span>
    <span>War Card Game (Java, OOP)</span>
  </div>

  <div class="close-hint">[ click anywhere to close ]</div>
</div>

<div id="pub-modal" class="paper-modal">
  <h2>Publications</h2>
  <p style="margin-bottom:6px; color:rgba(40,40,35,0.7); font-size:12px;">Hinojosa, C., et al. "TrainYourSnakeAI: A Novel Tool to Teach Reinforcement Learning to Middle School Students" — Proceedings of the 56th ACM Technical Symposium on Computer Science Education V. 1.</p>
  <a class="modal-link" href="https://doi.org/10.1145/3641554.3701907" target="_blank" rel="noopener noreferrer">Read Paper</a>
  <div class="close-hint">[ click anywhere to close ]</div>
</div>

<div id="about-modal">
  <h2>About Me</h2>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>
  <div class="close-hint">[ click anywhere to close ]</div>
</div>

<div id="linkedin-modal">
  <h2>LinkedIn</h2>
  <p>Connect with me on LinkedIn to see my professional experience and stay in touch.</p>
  <a class="modal-link" href="https://www.linkedin.com/in/cesar-hinojosa" target="_blank" rel="noopener noreferrer">Visit LinkedIn Profile</a>
  <div class="close-hint">[ click anywhere to close ]</div>
</div>

<div id="github-modal">
  <h2>GitHub</h2>
  <p>Check out my GitHub to explore the projects and code I've been working on.</p>
  <a class="modal-link" href="https://github.com/cesarihinojosa" target="_blank" rel="noopener noreferrer">Visit GitHub Profile</a>
  <div class="close-hint">[ click anywhere to close ]</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(() => {
  // --- Scene Setup ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x1a1a2a, 1, 30);

  const camera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 1.7, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(1);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;
  renderer.autoClear = false;
  document.body.appendChild(renderer.domElement);

  // --- Room Geometry ---
  const ROOM_SIZE = 8;
  const HALF = ROOM_SIZE / 2;
  const ROOM_HEIGHT = 4;
  const HALF_H = ROOM_HEIGHT / 2;

  // Textured materials for the walls/floor/ceiling
  function makeWallMaterial(color) {
    return new THREE.MeshStandardMaterial({
      color,
      roughness: 0.92,
      metalness: 0.02,
      side: THREE.BackSide
    });
  }

  // Floor with subtle grid
  const floorCanvas = document.createElement('canvas');
  floorCanvas.width = 512; floorCanvas.height = 512;
  const fctx = floorCanvas.getContext('2d');
  fctx.fillStyle = '#3a3a3a';
  fctx.fillRect(0, 0, 512, 512);
  fctx.strokeStyle = '#444';
  fctx.lineWidth = 1;
  for (let i = 0; i <= 512; i += 64) {
    fctx.beginPath(); fctx.moveTo(i, 0); fctx.lineTo(i, 512); fctx.stroke();
    fctx.beginPath(); fctx.moveTo(0, i); fctx.lineTo(512, i); fctx.stroke();
  }
  const floorTex = new THREE.CanvasTexture(floorCanvas);
  floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
  floorTex.repeat.set(4, 4);

  const floorMat = new THREE.MeshStandardMaterial({
    map: floorTex,
    roughness: 0.85,
    metalness: 0.05,
  });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Ceiling
  const ceilMat = new THREE.MeshStandardMaterial({ color: 0x505050, roughness: 0.95, metalness: 0.0 });
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE), ceilMat);
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = ROOM_HEIGHT;
  ceiling.receiveShadow = true;
  scene.add(ceiling);

  // Walls
  const wallColor = 0x555555;
  const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.9, metalness: 0.02 });

  // Front wall — with circular porthole window near the couch
  const portholeX = -2.5;       // shape-space offset (negative = right side in world after PI rotation)
  const portholeY = 0.0;        // offset from wall center (eye-level when seated)
  const portholeR = 0.55;       // porthole radius

  function makeWallWithCircularHole(wallW, wallH, cx, cy, radius) {
    const s = new THREE.Shape();
    s.moveTo(-wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, -wallH / 2);
    const h = new THREE.Path();
    h.absarc(cx, cy, radius, 0, Math.PI * 2, true);
    s.holes.push(h);
    return new THREE.ShapeGeometry(s);
  }

  const frontWallGeo = makeWallWithCircularHole(ROOM_SIZE, ROOM_HEIGHT, portholeX, portholeY, portholeR);
  const frontWall = new THREE.Mesh(frontWallGeo, wallMat);
  frontWall.position.set(0, HALF_H, HALF);
  frontWall.rotation.set(0, Math.PI, 0);
  frontWall.receiveShadow = true;
  scene.add(frontWall);

  // --- Space Window wraps: left side (back half) → back wall → right side (back half) ---
  // The window extends across 3 wall segments with a consistent margin from floor/ceiling.
  // Side windows go from z = -HALF to z = 0 (half the wall length).

  const winMargin = 0.6;
  const winH = ROOM_HEIGHT - winMargin * 2;
  const sideWinLen = HALF;   // half the wall = 6 units on each side

  // Helper: create a wall shape with a rectangular window hole
  function makeWallWithHole(wallW, wallH, holeW, holeH) {
    const s = new THREE.Shape();
    s.moveTo(-wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, -wallH / 2);
    s.lineTo(wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, wallH / 2);
    s.lineTo(-wallW / 2, -wallH / 2);
    const h = new THREE.Path();
    h.moveTo(-holeW / 2, -holeH / 2);
    h.lineTo(holeW / 2, -holeH / 2);
    h.lineTo(holeW / 2, holeH / 2);
    h.lineTo(-holeW / 2, holeH / 2);
    h.lineTo(-holeW / 2, -holeH / 2);
    s.holes.push(h);
    return new THREE.ShapeGeometry(s);
  }

  const winWallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9, metalness: 0.02 });

  // Back wall — full width window (no side margins, flush to corners)
  const backWinW = ROOM_SIZE - winMargin * 2;
  const backWallGeo = makeWallWithHole(ROOM_SIZE, ROOM_HEIGHT, backWinW, winH);
  const backWall = new THREE.Mesh(backWallGeo, winWallMat);
  backWall.position.set(0, HALF_H, -HALF);
  backWall.receiveShadow = true;
  scene.add(backWall);

  // Left wall — split into two halves:
  //   Back half (z: -HALF to 0) has a window hole
  //   Front half (z: 0 to HALF) is solid
  const sideWinW = sideWinLen - winMargin; // window width on side walls (margin only at the front edge)
  const leftBackGeo = makeWallWithHole(sideWinLen, ROOM_HEIGHT, sideWinW, winH);
  const leftBack = new THREE.Mesh(leftBackGeo, winWallMat);
  leftBack.position.set(-HALF, HALF_H, -HALF / 2);
  leftBack.rotation.set(0, Math.PI / 2, 0);
  leftBack.receiveShadow = true;
  scene.add(leftBack);

  const leftFront = new THREE.Mesh(new THREE.PlaneGeometry(sideWinLen, ROOM_HEIGHT), wallMat);
  leftFront.position.set(-HALF, HALF_H, HALF / 2);
  leftFront.rotation.set(0, Math.PI / 2, 0);
  leftFront.receiveShadow = true;
  scene.add(leftFront);

  // Right wall — same split
  const rightBackGeo = makeWallWithHole(sideWinLen, ROOM_HEIGHT, sideWinW, winH);
  const rightBack = new THREE.Mesh(rightBackGeo, winWallMat);
  rightBack.position.set(HALF, HALF_H, -HALF / 2);
  rightBack.rotation.set(0, -Math.PI / 2, 0);
  rightBack.receiveShadow = true;
  scene.add(rightBack);

  const rightFront = new THREE.Mesh(new THREE.PlaneGeometry(sideWinLen, ROOM_HEIGHT), wallMat);
  rightFront.position.set(HALF, HALF_H, HALF / 2);
  rightFront.rotation.set(0, -Math.PI / 2, 0);
  rightFront.receiveShadow = true;
  scene.add(rightFront);

  // --- Space Skybox Scene ---
  // A completely separate scene rendered at infinity (follows camera rotation only).
  const spaceScene = new THREE.Scene();
  const spaceCamera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 1000);

  // Giant sphere with space texture on the inside
  const spaceCanvas = document.createElement('canvas');
  spaceCanvas.width = 4096;
  spaceCanvas.height = 2048;
  const sctx = spaceCanvas.getContext('2d');

  // Deep space background
  sctx.fillStyle = '#000005';
  sctx.fillRect(0, 0, 4096, 2048);

  // Nebula clouds
  function drawNebula(cx, cy, radius, r, g, b, alpha) {
    const grad = sctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
    grad.addColorStop(0, `rgba(${r},${g},${b},${alpha})`);
    grad.addColorStop(0.3, `rgba(${r},${g},${b},${alpha * 0.6})`);
    grad.addColorStop(0.6, `rgba(${r},${g},${b},${alpha * 0.2})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    sctx.fillStyle = grad;
    sctx.fillRect(0, 0, 4096, 2048);
  }

  drawNebula(800, 600, 500, 60, 20, 120, 0.3);
  drawNebula(3000, 400, 600, 20, 50, 140, 0.22);
  drawNebula(2000, 1400, 700, 100, 30, 60, 0.18);
  drawNebula(3400, 1300, 400, 30, 80, 100, 0.15);
  drawNebula(600, 1500, 350, 80, 40, 120, 0.12);
  drawNebula(1600, 500, 450, 40, 30, 100, 0.2);

  // Stars
  function drawStars(count, minSize, maxSize, minAlpha, maxAlpha) {
    for (let i = 0; i < count; i++) {
      const x = Math.random() * 4096;
      const y = Math.random() * 2048;
      const size = minSize + Math.random() * (maxSize - minSize);
      const alpha = minAlpha + Math.random() * (maxAlpha - minAlpha);
      const temp = Math.random();
      let r = 255, g = 255, b = 255;
      if (temp < 0.15) { r = 180; g = 200; b = 255; }
      else if (temp < 0.25) { r = 255; g = 220; b = 180; }
      else if (temp < 0.3) { r = 255; g = 180; b = 160; }
      sctx.beginPath();
      sctx.arc(x, y, size, 0, Math.PI * 2);
      sctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      sctx.fill();
      if (size > 1.8) {
        const glow = sctx.createRadialGradient(x, y, 0, x, y, size * 5);
        glow.addColorStop(0, `rgba(${r},${g},${b},${alpha * 0.3})`);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        sctx.fillStyle = glow;
        sctx.fillRect(x - size * 5, y - size * 5, size * 10, size * 10);
      }
    }
  }

  drawStars(4000, 0.3, 1.0, 0.3, 0.8);
  drawStars(800, 0.8, 1.8, 0.6, 1.0);
  drawStars(120, 1.5, 3.0, 0.8, 1.0);

  // Planet — draw on the canvas at a position that maps to the -Z direction
  // On an equirectangular map, -Z is at the center (x=2048, y=1024)
  const planetX = 2300, planetY = 1100, planetR = 150;
  sctx.save();
  sctx.beginPath();
  sctx.arc(planetX, planetY, planetR, 0, Math.PI * 2);
  sctx.clip();
  const planetGrad = sctx.createLinearGradient(planetX - planetR, planetY, planetX + planetR, planetY);
  planetGrad.addColorStop(0, '#2a4a6a');
  planetGrad.addColorStop(0.3, '#3a6a8a');
  planetGrad.addColorStop(0.6, '#2a5a7a');
  planetGrad.addColorStop(1, '#1a3a5a');
  sctx.fillStyle = planetGrad;
  sctx.fillRect(planetX - planetR, planetY - planetR, planetR * 2, planetR * 2);
  sctx.globalAlpha = 0.15;
  for (let i = 0; i < 10; i++) {
    const bandY = planetY - planetR + (planetR * 2 / 10) * i;
    sctx.fillStyle = i % 2 === 0 ? '#4a8aaa' : '#2a5a7a';
    sctx.fillRect(planetX - planetR, bandY, planetR * 2, planetR * 2 / 10);
  }
  sctx.globalAlpha = 1.0;
  const shadowGrad = sctx.createLinearGradient(planetX - planetR * 0.3, planetY, planetX + planetR, planetY);
  shadowGrad.addColorStop(0, 'rgba(0,0,0,0)');
  shadowGrad.addColorStop(0.5, 'rgba(0,0,0,0.3)');
  shadowGrad.addColorStop(1, 'rgba(0,0,0,0.85)');
  sctx.fillStyle = shadowGrad;
  sctx.fillRect(planetX - planetR, planetY - planetR, planetR * 2, planetR * 2);
  sctx.restore();
  // Atmosphere glow
  const atmoGrad = sctx.createRadialGradient(planetX, planetY, planetR * 0.95, planetX, planetY, planetR * 1.2);
  atmoGrad.addColorStop(0, 'rgba(100,180,255,0)');
  atmoGrad.addColorStop(0.5, 'rgba(100,180,255,0.06)');
  atmoGrad.addColorStop(1, 'rgba(100,180,255,0)');
  sctx.fillStyle = atmoGrad;
  sctx.beginPath();
  sctx.arc(planetX, planetY, planetR * 1.2, 0, Math.PI * 2);
  sctx.fill();

  // Small moon
  const moonX = 1700, moonY = 700, moonR = 45;
  sctx.beginPath();
  sctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
  const moonGrad = sctx.createRadialGradient(moonX - 10, moonY - 10, 0, moonX, moonY, moonR);
  moonGrad.addColorStop(0, '#8a7a6a');
  moonGrad.addColorStop(1, '#3a3530');
  sctx.fillStyle = moonGrad;
  sctx.fill();

  // Distant galaxy
  sctx.save();
  sctx.translate(1900, 500);
  sctx.rotate(0.4);
  sctx.scale(1, 0.3);
  const galaxyGrad = sctx.createRadialGradient(0, 0, 0, 0, 0, 140);
  galaxyGrad.addColorStop(0, 'rgba(200,180,255,0.22)');
  galaxyGrad.addColorStop(0.3, 'rgba(160,140,220,0.1)');
  galaxyGrad.addColorStop(1, 'rgba(0,0,0,0)');
  sctx.fillStyle = galaxyGrad;
  sctx.fillRect(-140, -140, 280, 280);
  sctx.restore();

  const spaceTex = new THREE.CanvasTexture(spaceCanvas);

  // Sky sphere — large sphere with the space texture on the inside
  const skyGeo = new THREE.SphereGeometry(500, 64, 32);
  const skyMat = new THREE.MeshBasicMaterial({
    map: spaceTex,
    side: THREE.BackSide,
    depthWrite: false,
  });
  const skySphere = new THREE.Mesh(skyGeo, skyMat);
  spaceScene.add(skySphere);

  // --- Window frame pieces (dark metal frame wrapping all 3 walls) ---
  const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4, metalness: 0.6 });
  const frameDepth = 0.05;
  const frameThick = 0.08;

  // Back wall frames — horizontal bars
  function addBackFrameH(y) {
    const geo = new THREE.BoxGeometry(backWinW + frameThick * 2, frameThick, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.position.set(0, y, -HALF + frameDepth / 2);
    mesh.castShadow = true;
    scene.add(mesh);
  }
  addBackFrameH(winMargin);
  addBackFrameH(ROOM_HEIGHT - winMargin);
  addBackFrameH(HALF_H);

  // Back wall frames — vertical dividers
  function addBackFrameV(x) {
    const geo = new THREE.BoxGeometry(frameThick, winH + frameThick * 2, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.position.set(x, HALF_H, -HALF + frameDepth / 2);
    mesh.castShadow = true;
    scene.add(mesh);
  }
  addBackFrameV(-backWinW / 6);
  addBackFrameV(backWinW / 6);

  // Left side wall frames — horizontal bars
  function addSideFrameH(wallX, y, len, rotY) {
    const geo = new THREE.BoxGeometry(len, frameThick, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    // Position at the side wall, offset inward by frameDepth/2
    const inset = frameDepth / 2;
    const sign = wallX > 0 ? -1 : 1;
    mesh.position.set(wallX + sign * inset, y, -HALF / 2);
    mesh.rotation.set(0, rotY, 0);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Left wall horizontal frames
  addSideFrameH(-HALF, winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(-HALF, ROOM_HEIGHT - winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(-HALF, HALF_H, sideWinW + frameThick, Math.PI / 2);

  // Right wall horizontal frames
  addSideFrameH(HALF, winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(HALF, ROOM_HEIGHT - winMargin, sideWinW + frameThick, Math.PI / 2);
  addSideFrameH(HALF, HALF_H, sideWinW + frameThick, Math.PI / 2);

  // Side wall vertical dividers
  function addSideFrameV(wallX, z, rotY) {
    const geo = new THREE.BoxGeometry(frameThick, winH + frameThick * 2, frameDepth);
    const mesh = new THREE.Mesh(geo, frameMat);
    const inset = frameDepth / 2;
    const sign = wallX > 0 ? -1 : 1;
    mesh.position.set(wallX + sign * inset, HALF_H, z);
    mesh.rotation.set(0, rotY, 0);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Left wall — front edge frame + center divider
  addSideFrameV(-HALF, -winMargin, Math.PI / 2);        // front edge (where window ends)
  addSideFrameV(-HALF, -HALF / 2, Math.PI / 2);         // center divider

  // Right wall — front edge frame + center divider
  addSideFrameV(HALF, -winMargin, Math.PI / 2);
  addSideFrameV(HALF, -HALF / 2, Math.PI / 2);

  // --- Circular Porthole Window Frame (front wall, right of couch) ---
  // World position of porthole center: negate portholeX because wall is rotated PI
  const portholeWorldX = -portholeX;  // -(-2.5) = 2.5 in world space (right of couch)
  const portholeWorldY = HALF_H + portholeY;
  const portholeWorldZ = HALF;

  // Outer ring — thick torus
  const portFrameGeo = new THREE.TorusGeometry(portholeR + 0.02, 0.06, 16, 64);
  const portFrame = new THREE.Mesh(portFrameGeo, frameMat);
  portFrame.position.set(portholeWorldX, portholeWorldY, portholeWorldZ - 0.01);
  portFrame.castShadow = true;
  scene.add(portFrame);

  // Inner ring — thinner accent ring
  const portInnerGeo = new THREE.TorusGeometry(portholeR - 0.03, 0.025, 12, 64);
  const portInner = new THREE.Mesh(portInnerGeo, frameMat);
  portInner.position.set(portholeWorldX, portholeWorldY, portholeWorldZ - 0.03);
  portInner.castShadow = true;
  scene.add(portInner);

  // Cross bars — 4 thin bars across the porthole (like a nautical porthole)
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI;
    const barLen = portholeR * 2 - 0.08;
    const barGeo = new THREE.BoxGeometry(barLen, 0.025, frameDepth * 0.6);
    const bar = new THREE.Mesh(barGeo, frameMat);
    bar.position.set(portholeWorldX, portholeWorldY, portholeWorldZ - 0.02);
    bar.rotation.z = angle;
    bar.castShadow = true;
    scene.add(bar);
  }

  // Subtle blue light through the porthole
  const portholeLight = new THREE.PointLight(0x4488cc, 0.6, 6, 1.5);
  portholeLight.position.set(portholeWorldX, portholeWorldY, portholeWorldZ - 0.3);
  scene.add(portholeLight);

  // --- Sheer open curtains on all windows ---
  const curtainMat = new THREE.MeshStandardMaterial({
    color: 0xd8d0c4, roughness: 0.9, metalness: 0.0,
    side: THREE.DoubleSide, transparent: true, opacity: 0.45
  });

  function makeCurtainGeo(cw, ch, folds) {
    const geo = new THREE.PlaneGeometry(cw, ch, folds * 4, 12);
    const pos = geo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const y = pos.getY(i);
      // Wavy folds along X
      const wave = Math.sin(x / cw * folds * Math.PI * 2) * 0.03;
      // Gather toward edges (open curtain bunching)
      const gatherX = Math.sign(x) * Math.pow(Math.abs(x / (cw / 2)), 0.6) * (cw / 2);
      // Slight drape sag
      const sag = (1 - Math.abs(y / (ch / 2))) * 0.015;
      pos.setX(i, gatherX);
      pos.setZ(i, wave + sag);
    }
    geo.computeVertexNormals();
    return geo;
  }

  // Back wall curtains — one pair for the full window
  const backCurtH = winH + 0.2;
  const backCurtW = backWinW * 0.18; // each curtain panel width
  const backCurtGeo = makeCurtainGeo(backCurtW, backCurtH, 6);

  // Left curtain panel (bunched to left side of back window, outside frame)
  const bcL = new THREE.Mesh(backCurtGeo, curtainMat);
  bcL.position.set(-backWinW / 2 - frameThick / 2 - backCurtW / 2 * 0.3, HALF_H, -HALF + frameDepth + 0.03);
  bcL.castShadow = true;
  scene.add(bcL);

  // Right curtain panel (bunched to right side of back window, outside frame)
  const bcR = new THREE.Mesh(backCurtGeo, curtainMat);
  bcR.position.set(backWinW / 2 + frameThick / 2 + backCurtW / 2 * 0.3, HALF_H, -HALF + frameDepth + 0.03);
  bcR.castShadow = true;
  scene.add(bcR);

  // Side wall curtains — left wall (back half, z: -HALF to 0)
  const sideCurtH = winH + 0.2;
  const sideCurtW = sideWinW * 0.2;
  const sideCurtGeo = makeCurtainGeo(sideCurtW, sideCurtH, 5);

  // Left wall — curtain near back corner (just past the corner)
  const scLBack = new THREE.Mesh(sideCurtGeo, curtainMat);
  scLBack.position.set(-HALF + frameDepth + 0.03, HALF_H, -HALF + frameThick / 2 + sideCurtW / 2 * 0.3);
  scLBack.rotation.y = Math.PI / 2;
  scLBack.castShadow = true;
  scene.add(scLBack);

  // Left wall — curtain near front edge (outside the front frame divider)
  const scLFront = new THREE.Mesh(sideCurtGeo, curtainMat);
  scLFront.position.set(-HALF + frameDepth + 0.03, HALF_H, -winMargin + frameThick / 2 + sideCurtW / 2 * 0.3);
  scLFront.rotation.y = Math.PI / 2;
  scLFront.castShadow = true;
  scene.add(scLFront);

  // Right wall — curtain near back corner
  const scRBack = new THREE.Mesh(sideCurtGeo, curtainMat);
  scRBack.position.set(HALF - frameDepth - 0.03, HALF_H, -HALF + frameThick / 2 + sideCurtW / 2 * 0.3);
  scRBack.rotation.y = -Math.PI / 2;
  scRBack.castShadow = true;
  scene.add(scRBack);

  // Right wall — curtain near front edge
  const scRFront = new THREE.Mesh(sideCurtGeo, curtainMat);
  scRFront.position.set(HALF - frameDepth - 0.03, HALF_H, -winMargin + frameThick / 2 + sideCurtW / 2 * 0.3);
  scRFront.rotation.y = -Math.PI / 2;
  scRFront.castShadow = true;
  scene.add(scRFront);

  // --- Curtain rods ---
  const rodMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.35, metalness: 0.7 });
  const rodR = 0.012;
  const rodY = ROOM_HEIGHT - winMargin + frameThick / 2 + 0.04;
  const finialR = 0.022;

  // Back wall rod — spans full window width plus overhang
  const backRodLen = backWinW + frameThick * 2 + 0.3;
  const backRod = new THREE.Mesh(new THREE.CylinderGeometry(rodR, rodR, backRodLen, 8), rodMat);
  backRod.position.set(0, rodY, -HALF + frameDepth + 0.03);
  backRod.rotation.z = Math.PI / 2;
  backRod.castShadow = true;
  scene.add(backRod);
  // Finials
  const backFinL = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  backFinL.position.set(-backRodLen / 2, rodY, -HALF + frameDepth + 0.03);
  scene.add(backFinL);
  const backFinR = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  backFinR.position.set(backRodLen / 2, rodY, -HALF + frameDepth + 0.03);
  scene.add(backFinR);

  // Left wall rod — spans the window section
  const sideRodLen = sideWinW + frameThick + 0.2;
  const sideRodZ = -HALF / 2;  // center of the side window area

  const leftRod = new THREE.Mesh(new THREE.CylinderGeometry(rodR, rodR, sideRodLen, 8), rodMat);
  leftRod.position.set(-HALF + frameDepth + 0.03, rodY, sideRodZ);
  leftRod.rotation.x = Math.PI / 2;
  leftRod.castShadow = true;
  scene.add(leftRod);
  // Finials
  const lFinBack = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  lFinBack.position.set(-HALF + frameDepth + 0.03, rodY, sideRodZ - sideRodLen / 2);
  scene.add(lFinBack);
  const lFinFront = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  lFinFront.position.set(-HALF + frameDepth + 0.03, rodY, sideRodZ + sideRodLen / 2);
  scene.add(lFinFront);

  // Right wall rod
  const rightRod = new THREE.Mesh(new THREE.CylinderGeometry(rodR, rodR, sideRodLen, 8), rodMat);
  rightRod.position.set(HALF - frameDepth - 0.03, rodY, sideRodZ);
  rightRod.rotation.x = Math.PI / 2;
  rightRod.castShadow = true;
  scene.add(rightRod);
  // Finials
  const rFinBack = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  rFinBack.position.set(HALF - frameDepth - 0.03, rodY, sideRodZ - sideRodLen / 2);
  scene.add(rFinBack);
  const rFinFront = new THREE.Mesh(new THREE.SphereGeometry(finialR, 8, 8), rodMat);
  rFinFront.position.set(HALF - frameDepth - 0.03, rodY, sideRodZ + sideRodLen / 2);
  scene.add(rFinFront);

  // --- Window lighting ---
  // Blue light spill from the back window
  const spaceLight = new THREE.PointLight(0x4466aa, 0.5, 12);
  spaceLight.position.set(0, HALF_H, -HALF + 1);
  scene.add(spaceLight);

  const spaceSpot = new THREE.SpotLight(0x334466, 0.3, 10, Math.PI / 3, 0.5);
  spaceSpot.position.set(0, ROOM_HEIGHT - 1, -HALF + 0.5);
  spaceSpot.target.position.set(0, 0, -HALF + 3);
  scene.add(spaceSpot);
  scene.add(spaceSpot.target);

  // Side window light spill
  const leftWinLight = new THREE.PointLight(0x3355aa, 0.35, 10);
  leftWinLight.position.set(-HALF + 1, HALF_H, -HALF / 2);
  scene.add(leftWinLight);

  const rightWinLight = new THREE.PointLight(0x3355aa, 0.35, 10);
  rightWinLight.position.set(HALF - 1, HALF_H, -HALF / 2);
  scene.add(rightWinLight);

  // --- Edge Lines (subtle) ---
  const edgeMat = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3 });
  const edges = [
    // floor edges
    [[-HALF,0,-HALF],[HALF,0,-HALF]],
    [[HALF,0,-HALF],[HALF,0,HALF]],
    [[HALF,0,HALF],[-HALF,0,HALF]],
    [[-HALF,0,HALF],[-HALF,0,-HALF]],
    // ceiling edges
    [[-HALF,ROOM_HEIGHT,-HALF],[HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,ROOM_HEIGHT,-HALF],[HALF,ROOM_HEIGHT,HALF]],
    [[HALF,ROOM_HEIGHT,HALF],[-HALF,ROOM_HEIGHT,HALF]],
    [[-HALF,ROOM_HEIGHT,HALF],[-HALF,ROOM_HEIGHT,-HALF]],
    // verticals
    [[-HALF,0,-HALF],[-HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,0,-HALF],[HALF,ROOM_HEIGHT,-HALF]],
    [[HALF,0,HALF],[HALF,ROOM_HEIGHT,HALF]],
    [[-HALF,0,HALF],[-HALF,ROOM_HEIGHT,HALF]],
  ];
  edges.forEach(([a, b]) => {
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(...a), new THREE.Vector3(...b)]);
    scene.add(new THREE.Line(geo, edgeMat));
  });

  // --- Lighting ---


  // Dim ambient
  scene.add(new THREE.AmbientLight(0x888899, 0.3));

  // Secondary fill light
  const fillLight = new THREE.PointLight(0xaabbcc, 0.15, 15);
  fillLight.position.set(-3, 1, 3);
  scene.add(fillLight);

  // --- Neon Sign on Ceiling ("CESAR HINOJOSA") ---
  const neonCanvas = document.createElement('canvas');
  neonCanvas.width = 1024; neonCanvas.height = 256;
  const nctx = neonCanvas.getContext('2d');

  // Transparent background
  nctx.clearRect(0, 0, 1024, 256);

  // Glow layers (drawn first, behind the text)
  const neonText = 'CESAR HINOJOSA';
  nctx.textAlign = 'center';
  nctx.textBaseline = 'middle';

  // Outer glow
  nctx.font = 'bold 90px Arial, Helvetica, sans-serif';
  nctx.shadowColor = '#ffffff';
  nctx.shadowBlur = 50;
  nctx.fillStyle = 'rgba(255,255,255,0.3)';
  nctx.fillText(neonText, 512, 128);
  nctx.fillText(neonText, 512, 128);

  // Mid glow
  nctx.shadowBlur = 25;
  nctx.fillStyle = 'rgba(255,255,255,0.5)';
  nctx.fillText(neonText, 512, 128);

  // Core text
  nctx.shadowBlur = 10;
  nctx.fillStyle = '#ffffff';
  nctx.fillText(neonText, 512, 128);

  const neonTex = new THREE.CanvasTexture(neonCanvas);
  neonTex.minFilter = THREE.LinearFilter;

  // Sign plane — emissive so it glows
  const neonSignMat = new THREE.MeshBasicMaterial({
    map: neonTex,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
  });
  const neonSignW = 3.5, neonSignH = 0.85;
  const neonSign = new THREE.Mesh(new THREE.PlaneGeometry(neonSignW, neonSignH), neonSignMat);
  neonSign.rotation.x = Math.PI / 2;
  neonSign.position.set(0, ROOM_HEIGHT - 0.02, -HALF + 0.5);
  scene.add(neonSign);

  // Neon glow light casting downward
  const neonGlow = new THREE.PointLight(0xffffff, 0.6, 8, 2);
  neonGlow.position.set(0, ROOM_HEIGHT - 0.1, -HALF + 0.5);
  scene.add(neonGlow);

  // Wider soft wash
  const neonFill = new THREE.PointLight(0xeeeeff, 0.2, 12, 2);
  neonFill.position.set(0, ROOM_HEIGHT - 0.1, -HALF + 0.5);
  scene.add(neonFill);

  // --- L-Shape Desk (along back window wall + left side window wall) ---
  const deskY = 0.75;
  const deskThick = 0.06;
  const deskD = 0.95;          // depth (away from wall)
  const deskMargin = 1;     // gap from side walls

  const deskMat = new THREE.MeshStandardMaterial({ color: 0x3e1d00, roughness: 0.5, metalness: 0.35 });
  const deskPanelMat = new THREE.MeshStandardMaterial({ color: 0x3e1d00, roughness: 0.45, metalness: 0.4 });
  const deskLegMat = new THREE.MeshStandardMaterial({ color: 0x3e1d00, roughness: 0.4, metalness: 0.5 });

  // --- Back section (along z = -HALF, spans nearly wall to wall) ---
  const backDeskW = ROOM_SIZE - deskMargin * 2;
  const backDeskZ = -HALF + deskD / 1.5;

  // Desktop surface
  const backTop = new THREE.Mesh(new THREE.BoxGeometry(backDeskW, deskThick, deskD), deskMat);
  backTop.position.set(0, deskY, backDeskZ);
  backTop.castShadow = true; backTop.receiveShadow = true;
  scene.add(backTop);

  // Back panel (faces window / wall side)
  const backPanel = new THREE.Mesh(new THREE.BoxGeometry(backDeskW, deskY - 0.05, 0.04), deskPanelMat);
  backPanel.position.set(0, deskY / 2, backDeskZ - deskD / 2);
  backPanel.castShadow = true; backPanel.receiveShadow = true;
  scene.add(backPanel);

  // Legs — 2 at the ends (room-facing side)
  const backLegGeo = new THREE.BoxGeometry(0.06, deskY - 0.05, 0.06);
  [-backDeskW / 2 + 0.15, backDeskW / 2 - 0.15].forEach(x => {
    const leg = new THREE.Mesh(backLegGeo, deskLegMat);
    leg.position.set(x, (deskY - 0.05) / 2, backDeskZ + deskD / 2 - 0.1);
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // --- Left section (along x = -HALF, from back wall to z = 0 where window ends) ---
  const sideDeskLen = HALF - deskD / 2 - deskMargin;  // from back section edge to z = 0 minus margin
  const sideDeskX = -HALF + deskD / 1.5;
  const sideDeskZ = -HALF + deskD + sideDeskLen / 2;

  // Desktop surface
  const sideTop = new THREE.Mesh(new THREE.BoxGeometry(deskD, deskThick, sideDeskLen), deskMat);
  sideTop.position.set(sideDeskX, deskY, sideDeskZ);
  sideTop.castShadow = true; sideTop.receiveShadow = true;
  scene.add(sideTop);

  // Side panel (faces wall / window side)
  const sidePanel = new THREE.Mesh(new THREE.BoxGeometry(0.04, deskY - 0.05, sideDeskLen), deskPanelMat);
  sidePanel.position.set(sideDeskX - deskD / 2, deskY / 2, sideDeskZ);
  sidePanel.castShadow = true; sidePanel.receiveShadow = true;
  scene.add(sidePanel);


  // Legs — 2 along the side section (room-facing side)
  const sideLegGeo = new THREE.BoxGeometry(0.06, deskY - 0.05, 0.06);
  [sideDeskZ - sideDeskLen / 2 + 0.15, sideDeskZ + sideDeskLen / 2 - 0.15].forEach(z => {
    const leg = new THREE.Mesh(sideLegGeo, deskLegMat);
    leg.position.set(sideDeskX + deskD / 2 - 0.1, (deskY - 0.05) / 2, z);
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // --- Monitor (center of back desk section, facing room) ---
  const monX = 0, monZ = backDeskZ - deskD / 2 + 0.12;
  const monSurfY = deskY + deskThick / 2;
  const monW = 1.2, monH = 0.7;
  const monGroup = new THREE.Group();

  // Screen — canvas texture
  const monCanvas = document.createElement('canvas');
  monCanvas.width = 512; monCanvas.height = 384;
  const mctx = monCanvas.getContext('2d');
  mctx.fillStyle = '#0a0e14';
  mctx.fillRect(0, 0, 512, 384);
  // Label
  mctx.font = 'bold 48px monospace';
  mctx.fillStyle = 'rgba(60,180,255,0.9)';
  mctx.textAlign = 'center';
  mctx.fillText('About Me', 256, 120);
  // Hint
  mctx.font = '18px monospace';
  mctx.fillStyle = 'rgba(60,180,255,0.35)';
  mctx.fillText('[ click to read ]', 256, 170);
  mctx.textAlign = 'left';
  // Border
  mctx.strokeStyle = 'rgba(40,120,180,0.5)';
  mctx.lineWidth = 3;
  mctx.strokeRect(2, 2, 508, 380);

  const monTex = new THREE.CanvasTexture(monCanvas);
  const monScrMat = new THREE.MeshStandardMaterial({
    map: monTex, emissiveMap: monTex,
    emissive: new THREE.Color(0xffffff), emissiveIntensity: 0.4,
    roughness: 0.3, metalness: 0.1,
  });
  const monScreen = new THREE.Mesh(new THREE.PlaneGeometry(monW, monH), monScrMat);
  monScreen.position.set(0, monH / 2 + 0.02, 0);
  monScreen.rotation.x = -0.12;
  monGroup.add(monScreen);

  // Bezel
  const monBezelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1e, roughness: 0.3, metalness: 0.6 });
  const bz = 0.04;
  const mbt = new THREE.Mesh(new THREE.BoxGeometry(monW + bz * 2, bz, 0.04), monBezelMat);
  mbt.position.set(0, monH / 2 + 0.02 + monH / 2 + bz / 2, 0); mbt.rotation.x = -0.12; monGroup.add(mbt);
  const mbb = new THREE.Mesh(new THREE.BoxGeometry(monW + bz * 2, bz, 0.04), monBezelMat);
  mbb.position.set(0, monH / 2 + 0.02 - monH / 2 - bz / 2, 0); mbb.rotation.x = -0.12; monGroup.add(mbb);
  const mbl = new THREE.Mesh(new THREE.BoxGeometry(bz, monH + bz * 2, 0.04), monBezelMat);
  mbl.position.set(-monW / 2 - bz / 2, monH / 2 + 0.02, 0); mbl.rotation.x = -0.12; monGroup.add(mbl);
  const mbr = new THREE.Mesh(new THREE.BoxGeometry(bz, monH + bz * 2, 0.04), monBezelMat);
  mbr.position.set(monW / 2 + bz / 2, monH / 2 + 0.02, 0); mbr.rotation.x = -0.12; monGroup.add(mbr);

  // Stand
  const monStandMat = new THREE.MeshStandardMaterial({ color: 0x222226, roughness: 0.4, metalness: 0.5 });
  const monStand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.08), monStandMat);
  monStand.position.set(0, 0.05, 0); monGroup.add(monStand);

  // Base plate
  const monBase = new THREE.Mesh(new THREE.BoxGeometry(monW * 0.35, 0.03, 0.15), monStandMat);
  monBase.position.set(0, 0.015, 0.04); monGroup.add(monBase);

  monGroup.position.set(monX, monSurfY, monZ);
  monGroup.castShadow = true;
  scene.add(monGroup);

  // Monitor glow
  const monGlow = new THREE.PointLight(0x3388bb, 0.3, 4);
  monGlow.position.set(monX, monSurfY + monH / 2, monZ + 0.3);
  scene.add(monGlow);

  // --- Left Monitor (to the left of center monitor) ---
  const lMonX = monX - monW - 0.15, lMonZ = monZ + 0.3;
  const lMonW = 1.2, lMonH = 0.7;
  const lMonGroup = new THREE.Group();

  // Screen
  const lMonCanvas = document.createElement('canvas');
  lMonCanvas.width = 512; lMonCanvas.height = 384;
  const lmctx = lMonCanvas.getContext('2d');
  // Background
  lmctx.fillStyle = '#170a10';
  lmctx.fillRect(0, 0, 512, 384);
  // Scanlines
  lmctx.strokeStyle = 'rgba(255,80,180,0.04)';
  for (let y = 0; y < 384; y += 3) {
    lmctx.beginPath(); lmctx.moveTo(0, y); lmctx.lineTo(512, y); lmctx.stroke();
  }
  // "LinkedIn" title
  lmctx.font = 'bold 48px monospace';
  lmctx.fillStyle = 'rgba(255,80,180,0.9)';
  lmctx.textAlign = 'center';
  lmctx.fillText('LinkedIn', 256, 120);
  // Username
  lmctx.font = '26px monospace';
  lmctx.fillStyle = 'rgba(255,80,180,0.6)';
  lmctx.fillText('cesar-hinojosa', 256, 165);
  // Hint
  lmctx.font = '18px monospace';
  lmctx.fillStyle = 'rgba(255,80,180,0.35)';
  lmctx.fillText('[ click to visit ]', 256, 210);
  lmctx.textAlign = 'left';
  // Border
  lmctx.strokeStyle = 'rgba(255,80,180,0.4)';
  lmctx.lineWidth = 3;
  lmctx.strokeRect(2, 2, 508, 380);

  const lMonTex = new THREE.CanvasTexture(lMonCanvas);
  const lMonScrMat = new THREE.MeshStandardMaterial({
    map: lMonTex, emissiveMap: lMonTex,
    emissive: new THREE.Color(0xffffff), emissiveIntensity: 0.4,
    roughness: 0.3, metalness: 0.1,
  });
  const lMonScreen = new THREE.Mesh(new THREE.PlaneGeometry(lMonW, lMonH), lMonScrMat);
  lMonScreen.position.set(0, lMonH / 2 + 0.02, 0);
  lMonScreen.rotation.x = -0.12;
  lMonGroup.add(lMonScreen);

  // Bezel
  const lBz = 0.04;
  const lbt = new THREE.Mesh(new THREE.BoxGeometry(lMonW + lBz * 2, lBz, 0.04), monBezelMat);
  lbt.position.set(0, lMonH / 2 + 0.02 + lMonH / 2 + lBz / 2, 0); lbt.rotation.x = -0.12; lMonGroup.add(lbt);
  const lbb = new THREE.Mesh(new THREE.BoxGeometry(lMonW + lBz * 2, lBz, 0.04), monBezelMat);
  lbb.position.set(0, lMonH / 2 + 0.02 - lMonH / 2 - lBz / 2, 0); lbb.rotation.x = -0.12; lMonGroup.add(lbb);
  const lbl = new THREE.Mesh(new THREE.BoxGeometry(lBz, lMonH + lBz * 2, 0.04), monBezelMat);
  lbl.position.set(-lMonW / 2 - lBz / 2, lMonH / 2 + 0.02, 0); lbl.rotation.x = -0.12; lMonGroup.add(lbl);
  const lbr = new THREE.Mesh(new THREE.BoxGeometry(lBz, lMonH + lBz * 2, 0.04), monBezelMat);
  lbr.position.set(lMonW / 2 + lBz / 2, lMonH / 2 + 0.02, 0); lbr.rotation.x = -0.12; lMonGroup.add(lbr);

  // Stand
  const lMonStand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.08), monStandMat);
  lMonStand.position.set(0, 0.05, 0); lMonGroup.add(lMonStand);

  // Base plate
  const lMonBase = new THREE.Mesh(new THREE.BoxGeometry(lMonW * 0.35, 0.03, 0.15), monStandMat);
  lMonBase.position.set(0, 0.015, 0.04); lMonGroup.add(lMonBase);

  lMonGroup.position.set(lMonX, monSurfY, lMonZ);
  lMonGroup.rotation.y = 0.4;
  lMonGroup.castShadow = true;
  scene.add(lMonGroup);

  // Left monitor glow
  const lMonGlow = new THREE.PointLight(0xff50b4, 0.2, 4);
  lMonGlow.position.set(lMonX, monSurfY + lMonH / 2, lMonZ + 0.3);
  scene.add(lMonGlow);

  // --- Right Monitor (to the right of center monitor) ---
  const rMonX = monX + monW + 0.15, rMonZ = monZ + 0.3;
  const rMonW = 1.2, rMonH = 0.7;
  const rMonGroup = new THREE.Group();

  // Screen
  const rMonCanvas = document.createElement('canvas');
  rMonCanvas.width = 512; rMonCanvas.height = 384;
  const rmctx = rMonCanvas.getContext('2d');
  // Background
  rmctx.fillStyle = '#0d1117';
  rmctx.fillRect(0, 0, 512, 384);
  // Scanlines
  rmctx.strokeStyle = 'rgba(100,255,140,0.04)';
  for (let y = 0; y < 384; y += 3) {
    rmctx.beginPath(); rmctx.moveTo(0, y); rmctx.lineTo(512, y); rmctx.stroke();
  }
  // "GitHub" title
  rmctx.font = 'bold 48px monospace';
  rmctx.fillStyle = 'rgba(100,255,140,0.9)';
  rmctx.textAlign = 'center';
  rmctx.fillText('GitHub', 256, 120);
  // Username
  rmctx.font = '26px monospace';
  rmctx.fillStyle = 'rgba(100,255,140,0.6)';
  rmctx.fillText('@cesarihinojosa', 256, 165);
  // Hint
  rmctx.font = '18px monospace';
  rmctx.fillStyle = 'rgba(100,255,140,0.35)';
  rmctx.fillText('[ click to visit ]', 256, 210);
  rmctx.textAlign = 'left';
  // Border
  rmctx.strokeStyle = 'rgba(100,255,140,0.4)';
  rmctx.lineWidth = 3;
  rmctx.strokeRect(2, 2, 508, 380);

  const rMonTex = new THREE.CanvasTexture(rMonCanvas);
  const rMonScrMat = new THREE.MeshStandardMaterial({
    map: rMonTex, emissiveMap: rMonTex,
    emissive: new THREE.Color(0xffffff), emissiveIntensity: 0.4,
    roughness: 0.3, metalness: 0.1,
  });
  const rMonScreen = new THREE.Mesh(new THREE.PlaneGeometry(rMonW, rMonH), rMonScrMat);
  rMonScreen.position.set(0, rMonH / 2 + 0.02, 0);
  rMonScreen.rotation.x = -0.12;
  rMonGroup.add(rMonScreen);

  // Bezel
  const rBz = 0.04;
  const rbt = new THREE.Mesh(new THREE.BoxGeometry(rMonW + rBz * 2, rBz, 0.04), monBezelMat);
  rbt.position.set(0, rMonH / 2 + 0.02 + rMonH / 2 + rBz / 2, 0); rbt.rotation.x = -0.12; rMonGroup.add(rbt);
  const rbb = new THREE.Mesh(new THREE.BoxGeometry(rMonW + rBz * 2, rBz, 0.04), monBezelMat);
  rbb.position.set(0, rMonH / 2 + 0.02 - rMonH / 2 - rBz / 2, 0); rbb.rotation.x = -0.12; rMonGroup.add(rbb);
  const rbl = new THREE.Mesh(new THREE.BoxGeometry(rBz, rMonH + rBz * 2, 0.04), monBezelMat);
  rbl.position.set(-rMonW / 2 - rBz / 2, rMonH / 2 + 0.02, 0); rbl.rotation.x = -0.12; rMonGroup.add(rbl);
  const rbr = new THREE.Mesh(new THREE.BoxGeometry(rBz, rMonH + rBz * 2, 0.04), monBezelMat);
  rbr.position.set(rMonW / 2 + rBz / 2, rMonH / 2 + 0.02, 0); rbr.rotation.x = -0.12; rMonGroup.add(rbr);

  // Stand
  const rMonStand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.08), monStandMat);
  rMonStand.position.set(0, 0.05, 0); rMonGroup.add(rMonStand);

  // Base plate
  const rMonBase = new THREE.Mesh(new THREE.BoxGeometry(rMonW * 0.35, 0.03, 0.15), monStandMat);
  rMonBase.position.set(0, 0.015, 0.04); rMonGroup.add(rMonBase);

  rMonGroup.position.set(rMonX, monSurfY, rMonZ);
  rMonGroup.rotation.y = -0.4;
  rMonGroup.castShadow = true;
  scene.add(rMonGroup);

  // Right monitor glow
  const rMonGlow = new THREE.PointLight(0x33bb66, 0.2, 4);
  rMonGlow.position.set(rMonX, monSurfY + rMonH / 2, rMonZ + 0.3);
  scene.add(rMonGlow);

  // --- Neon Orange Lamp (on the L-desk corner) ---
  const dkLampX = sideDeskX, dkLampZ = sideDeskZ + sideDeskLen / 2 - 0.15;
  const dkLampBaseY = deskY + deskThick / 2;

  // Lamp base — small dark disc
  const dkLampBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.08, 0.025, 20),
    new THREE.MeshStandardMaterial({ color: 0x1a1a1e, roughness: 0.4, metalness: 0.5 })
  );
  dkLampBase.position.set(dkLampX, dkLampBaseY + 0.0125, dkLampZ);
  dkLampBase.castShadow = true;
  scene.add(dkLampBase);

  // Lamp pole — thin brass stem
  const dkPoleMat = new THREE.MeshStandardMaterial({ color: 0xAA8844, roughness: 0.35, metalness: 0.6 });
  const dkLampPole = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.25, 10), dkPoleMat);
  dkLampPole.position.set(dkLampX, dkLampBaseY + 0.15, dkLampZ);
  dkLampPole.castShadow = true;
  scene.add(dkLampPole);

  // Neon bulb
  const dkBulbMat = new THREE.MeshStandardMaterial({
    color: 0xFF6600,
    emissive: 0xFF6600,
    emissiveIntensity: 3.0,
    roughness: 0.05,
    metalness: 0.8,
  });
  const dkLampBulb = new THREE.Mesh(new THREE.SphereGeometry(0.06, 24, 24), dkBulbMat);
  dkLampBulb.position.set(dkLampX, dkLampBaseY + 0.34, dkLampZ);
  scene.add(dkLampBulb);

  // Neon glow layers
  [
    { radius: 0.10, color: 0xFFAA44, opacity: 0.4 },
    { radius: 0.20, color: 0xFF6600, opacity: 0.2 },
    { radius: 0.38, color: 0xFF5500, opacity: 0.09 },
    { radius: 0.65, color: 0xFF4400, opacity: 0.035 },
    { radius: 1.0,  color: 0xFF3300, opacity: 0.015 },
  ].forEach(g => {
    const mat = new THREE.MeshBasicMaterial({ color: g.color, transparent: true, opacity: g.opacity, depthWrite: false });
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(g.radius, 24, 24), mat);
    mesh.position.set(dkLampX, dkLampBaseY + 0.34, dkLampZ);
    scene.add(mesh);
  });

  // Primary neon point light
  const dkOrangeLight = new THREE.PointLight(0xFF5500, 1.8, 10, 1.5);
  dkOrangeLight.position.set(dkLampX, dkLampBaseY + 0.34, dkLampZ);
  dkOrangeLight.castShadow = false;
  scene.add(dkOrangeLight);

  // Secondary fill
  const dkOrangeFill = new THREE.PointLight(0xFF4400, 0.6, 16, 2);
  dkOrangeFill.position.set(dkLampX, dkLampBaseY + 0.34, dkLampZ);
  scene.add(dkOrangeFill);

  // --- Keyboard (beige, in front of center monitor) ---
  const kbW = 0.58, kbD = 0.21, kbH = 0.025;
  const kbY = monSurfY + kbH / 2;
  const kbZ = backDeskZ + 0.08;  // in front of monitor, toward user
  const kbMat = new THREE.MeshStandardMaterial({ color: 0xf0e6d0, roughness: 0.6, metalness: 0.1 });
  const kbBase = new THREE.Mesh(new THREE.BoxGeometry(kbW, kbH, kbD), kbMat);
  kbBase.position.set(monX, kbY, kbZ);
  kbBase.castShadow = true; kbBase.receiveShadow = true;
  scene.add(kbBase);

  // Slight tilt — raise back edge
  kbBase.rotation.x = -0.06;

  // Key rows
  const keyMat = new THREE.MeshStandardMaterial({ color: 0xe8dcc4, roughness: 0.7, metalness: 0.05 });
  const keyDarkMat = new THREE.MeshStandardMaterial({ color: 0xddd0b8, roughness: 0.7, metalness: 0.05 });
  const keySize = 0.028;
  const keyH = 0.01;
  const keyGap = 0.005;
  const keyCols = 14;
  const keyRows = 5;
  const kbStartX = -(keyCols * (keySize + keyGap)) / 2 + keySize / 2;
  const kbStartZ = -(keyRows * (keySize + keyGap)) / 2 + keySize / 2;
  const keyGeo = new THREE.BoxGeometry(keySize, keyH, keySize);
  for (let r = 0; r < keyRows; r++) {
    for (let c = 0; c < keyCols; c++) {
      const km = (r + c) % 3 === 0 ? keyDarkMat : keyMat;
      const key = new THREE.Mesh(keyGeo, km);
      key.position.set(
        kbStartX + c * (keySize + keyGap),
        kbH / 2 + keyH / 2,
        kbStartZ + r * (keySize + keyGap)
      );
      kbBase.add(key);
    }
  }
  // Spacebar (bottom row, wider)
  const spaceW = 0.16, spaceD = keySize;
  const spaceBar = new THREE.Mesh(new THREE.BoxGeometry(spaceW, keyH, spaceD), keyDarkMat);
  spaceBar.position.set(0, kbH / 2 + keyH / 2, kbStartZ + (keyRows) * (keySize + keyGap));
  kbBase.add(spaceBar);

  // --- Mouse (grey, to the right of keyboard) ---
  const mouseX = monX + kbW / 2 + 0.14;
  const mouseZ = kbZ + 0.02;
  const mouseY = monSurfY;
  const mouseMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.35, metalness: 0.2 });

  // Mouse body — rounded via capsule-like shape
  const mouseGroup = new THREE.Group();
  mouseGroup.position.set(mouseX, mouseY, mouseZ);

  const mouseBodyW = 0.06, mouseBodyD = 0.10, mouseBodyH = 0.028;
  const mouseBody = new THREE.Mesh(new THREE.BoxGeometry(mouseBodyW, mouseBodyH, mouseBodyD), mouseMat);
  mouseBody.position.y = mouseBodyH / 2;
  mouseBody.castShadow = true; mouseBody.receiveShadow = true;
  mouseGroup.add(mouseBody);

  // Rounded top (half-sphere on top of body)
  const mouseTop = new THREE.Mesh(
    new THREE.SphereGeometry(0.030, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
    mouseMat
  );
  mouseTop.position.y = mouseBodyH;
  mouseTop.scale.set(1, 0.6, 1.5);
  mouseGroup.add(mouseTop);

  // Scroll wheel
  const scrollMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5, metalness: 0.3 });
  const scrollWheel = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.016, 8), scrollMat);
  scrollWheel.rotation.z = Math.PI / 2;
  scrollWheel.position.set(0, mouseBodyH + 0.006, -0.016);
  mouseGroup.add(scrollWheel);

  // Button divider line
  const dividerMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.5, metalness: 0.2 });
  const divider = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.004, 0.04), dividerMat);
  divider.position.set(0, mouseBodyH + 0.007, -0.025);
  mouseGroup.add(divider);

  scene.add(mouseGroup);

  // --- Two sheets of paper with scribbles (on side desk, near lamp) ---
  const paperW = 0.18, paperD = 0.24, paperH = 0.002;
  const paperSurfY = deskY + deskThick / 2 + paperH / 2;
  const paperMeshes = [];

  // Paper 0: CV
  {
    const pCanvas = document.createElement('canvas');
    pCanvas.width = 256; pCanvas.height = 340;
    const pctx = pCanvas.getContext('2d');
    pctx.fillStyle = '#f5f2eb';
    pctx.fillRect(0, 0, 256, 340);

    // Title
    pctx.font = 'bold 16px monospace';
    pctx.fillStyle = 'rgba(40,40,35,0.8)';
    pctx.textAlign = 'center';
    pctx.fillText('CURRICULUM', 128, 32);
    pctx.fillText('VITAE', 128, 52);

    // Horizontal rule
    pctx.strokeStyle = 'rgba(40,50,70,0.4)';
    pctx.lineWidth = 1;
    pctx.beginPath(); pctx.moveTo(30, 64); pctx.lineTo(226, 64); pctx.stroke();

    // Scribble lines simulating CV text
    pctx.strokeStyle = 'rgba(40,50,70,0.45)';
    pctx.lineWidth = 1.2;
    const cvLines = [80, 100, 120, 140, 168, 188, 208, 228, 256, 276, 296];
    cvLines.forEach(ly => {
      const lineW = 50 + Math.random() * 160;
      pctx.beginPath(); pctx.moveTo(20, ly);
      for (let sx = 20; sx < 20 + lineW; sx += 8) {
        pctx.lineTo(sx, ly + (Math.random() - 0.5) * 3);
      }
      pctx.stroke();
    });

    const paperTex = new THREE.CanvasTexture(pCanvas);
    const paperMat2 = new THREE.MeshStandardMaterial({ map: paperTex, roughness: 0.85, metalness: 0.0 });
    const paperMesh = new THREE.Mesh(new THREE.BoxGeometry(paperW, paperH, paperD), paperMat2);
    paperMesh.position.set(sideDeskX, paperSurfY, sideDeskZ - 0.25);
    paperMesh.rotation.y = Math.PI / 2 + 0.1;
    paperMesh.castShadow = true; paperMesh.receiveShadow = true;
    scene.add(paperMesh);
    paperMeshes.push(paperMesh);
  }

  // Paper 1: Publications
  {
    const pCanvas = document.createElement('canvas');
    pCanvas.width = 256; pCanvas.height = 340;
    const pctx = pCanvas.getContext('2d');
    pctx.fillStyle = '#f0ece3';
    pctx.fillRect(0, 0, 256, 340);

    // Title
    pctx.font = 'bold 14px monospace';
    pctx.fillStyle = 'rgba(40,40,35,0.8)';
    pctx.textAlign = 'center';
    pctx.fillText('PUBLICATIONS', 128, 32);

    // Horizontal rule
    pctx.strokeStyle = 'rgba(40,50,70,0.4)';
    pctx.lineWidth = 1;
    pctx.beginPath(); pctx.moveTo(30, 44); pctx.lineTo(226, 44); pctx.stroke();

    // Simulated citation entries — groups of lines with gaps
    pctx.strokeStyle = 'rgba(40,50,70,0.45)';
    pctx.lineWidth = 1.2;
    const entryStarts = [60, 120, 180, 240];
    entryStarts.forEach(startY => {
      // Bullet dot
      pctx.fillStyle = 'rgba(40,50,70,0.5)';
      pctx.beginPath(); pctx.arc(18, startY + 2, 2.5, 0, Math.PI * 2); pctx.fill();
      // 3 lines per entry
      for (let l = 0; l < 3; l++) {
        const ly = startY + l * 16;
        const lineW = 60 + Math.random() * 150;
        pctx.beginPath(); pctx.moveTo(26, ly);
        for (let sx = 26; sx < 26 + lineW; sx += 8) {
          pctx.lineTo(sx, ly + (Math.random() - 0.5) * 3);
        }
        pctx.stroke();
      }
    });

    const paperTex = new THREE.CanvasTexture(pCanvas);
    const paperMat2 = new THREE.MeshStandardMaterial({ map: paperTex, roughness: 0.85, metalness: 0.0 });
    const paperMesh = new THREE.Mesh(new THREE.BoxGeometry(paperW, paperH, paperD), paperMat2);
    paperMesh.position.set(sideDeskX + 0.04, paperSurfY, sideDeskZ + 0.30);
    paperMesh.rotation.y = Math.PI / 2 - 0.08;
    paperMesh.castShadow = true; paperMesh.receiveShadow = true;
    scene.add(paperMesh);
    paperMeshes.push(paperMesh);
  }

  // --- Stack of books on back desk (left side, away from monitors) ---
  const stkColors = [0x8B2500, 0x1a3a5c, 0x2e4d2e, 0x6b3a6b, 0xc2713d];
  const stkX = -backDeskW / 2 + 0.25;
  const stkZ = backDeskZ;
  let stkY = deskY + deskThick / 2;
  for (let bi = 0; bi < stkColors.length; bi++) {
    const bkW = 0.32 + Math.random() * 0.1;
    const bkH = 0.04 + Math.random() * 0.025;
    const bkD = 0.22 + Math.random() * 0.06;
    const bkMat = new THREE.MeshStandardMaterial({ color: stkColors[bi], roughness: 0.7, metalness: 0.05 });
    const bk = new THREE.Mesh(new THREE.BoxGeometry(bkW, bkH, bkD), bkMat);
    bk.position.set(stkX + (Math.random() - 0.5) * 0.08, stkY + bkH / 2, stkZ + (Math.random() - 0.5) * 0.06);
    bk.rotation.y = (Math.random() - 0.5) * 0.4;
    bk.rotation.z = (Math.random() - 0.5) * 0.05;
    bk.castShadow = true; bk.receiveShadow = true;
    scene.add(bk);
    stkY += bkH;
  }

  // --- Globe (right end of back desk) ---
  const globeX = backDeskW / 2 - 0.3;
  const globeSurfY = deskY + deskThick / 2;
  const globeR = 0.12;
  const globeGroup = new THREE.Group();
  globeGroup.position.set(globeX, globeSurfY, backDeskZ);

  // Base
  const globeBaseMat = new THREE.MeshStandardMaterial({ color: 0x3B2314, roughness: 0.6, metalness: 0.15 });
  const globeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.02, 16), globeBaseMat);
  globeBase.position.y = 0.01;
  globeGroup.add(globeBase);

  // Stand post
  const globePost = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.1, 8), globeBaseMat);
  globePost.position.y = 0.07;
  globeGroup.add(globePost);

  // Axis ring
  const globeRingMat = new THREE.MeshStandardMaterial({ color: 0xc0a050, roughness: 0.3, metalness: 0.6 });
  const globeRing = new THREE.Mesh(new THREE.TorusGeometry(globeR + 0.005, 0.004, 8, 32), globeRingMat);
  globeRing.position.y = 0.12 + globeR;
  globeRing.rotation.x = 0.3;
  globeGroup.add(globeRing);

  // Globe sphere — canvas texture with land masses
  const globeCanvas = document.createElement('canvas');
  globeCanvas.width = 256; globeCanvas.height = 128;
  const gctx = globeCanvas.getContext('2d');
  gctx.fillStyle = '#1a4a7a';
  gctx.fillRect(0, 0, 256, 128);
  // Rough landmasses
  gctx.fillStyle = '#3a8a3a';
  [[30,20,50,35],[120,15,40,30],[90,50,60,25],[180,30,45,40],[20,60,35,20],[200,55,30,25]].forEach(function(b) {
    gctx.beginPath();
    gctx.ellipse(b[0], b[1], b[2]/2, b[3]/2, 0, 0, Math.PI*2);
    gctx.fill();
  });
  // Grid lines
  gctx.strokeStyle = 'rgba(255,255,255,0.12)';
  gctx.lineWidth = 0.5;
  for (let i = 0; i < 256; i += 32) { gctx.beginPath(); gctx.moveTo(i,0); gctx.lineTo(i,128); gctx.stroke(); }
  for (let i = 0; i < 128; i += 16) { gctx.beginPath(); gctx.moveTo(0,i); gctx.lineTo(256,i); gctx.stroke(); }

  const globeTex = new THREE.CanvasTexture(globeCanvas);
  const globeMat = new THREE.MeshStandardMaterial({ map: globeTex, roughness: 0.4, metalness: 0.1 });
  const globeSphere = new THREE.Mesh(new THREE.SphereGeometry(globeR, 24, 16), globeMat);
  globeSphere.position.y = 0.12 + globeR;
  globeGroup.add(globeSphere);

  scene.add(globeGroup);

  // --- Pencil cup (between book stack and left monitor) ---
  const cupX = stkX + 0.35;
  const cupZ = backDeskZ + 0.08;
  const cupR = 0.035, cupH = 0.1;
  const cupMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5, metalness: 0.3 });
  const cupMesh = new THREE.Mesh(new THREE.CylinderGeometry(cupR, cupR * 0.9, cupH, 12), cupMat);
  cupMesh.position.set(cupX, globeSurfY + cupH / 2, cupZ);
  cupMesh.castShadow = true;
  scene.add(cupMesh);

  // Pencils in the cup
  const pencilColors = [0xf0c040, 0xf0c040, 0xe06030, 0x3080d0, 0x2a2a2a];
  for (let pi2 = 0; pi2 < pencilColors.length; pi2++) {
    const pLen = 0.13 + Math.random() * 0.04;
    const pMat = new THREE.MeshStandardMaterial({ color: pencilColors[pi2], roughness: 0.6, metalness: 0.05 });
    const pencil = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, pLen, 6), pMat);
    const angle = (pi2 / pencilColors.length) * Math.PI * 2 + Math.random() * 0.3;
    const tilt = 0.1 + Math.random() * 0.15;
    pencil.position.set(
      cupX + Math.cos(angle) * 0.012,
      globeSurfY + cupH * 0.5 + pLen * 0.35,
      cupZ + Math.sin(angle) * 0.012
    );
    pencil.rotation.x = Math.cos(angle) * tilt;
    pencil.rotation.z = Math.sin(angle) * tilt;
    pencil.castShadow = true;
    scene.add(pencil);
    // Pencil tip
    const tipMat = new THREE.MeshStandardMaterial({ color: 0xdec9a0, roughness: 0.5, metalness: 0.05 });
    const tip = new THREE.Mesh(new THREE.ConeGeometry(0.005, 0.015, 6), tipMat);
    tip.position.y = pLen / 2 + 0.007;
    pencil.add(tip);
  }

  // --- Loose pencil on desk (near keyboard) ---
  const loosePMat = new THREE.MeshStandardMaterial({ color: 0xf0c040, roughness: 0.6, metalness: 0.05 });
  const loosePencil = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.16, 6), loosePMat);
  loosePencil.position.set(monX - kbW / 2 - 0.06, globeSurfY + 0.005, backDeskZ + 0.15);
  loosePencil.rotation.z = Math.PI / 2;
  loosePencil.rotation.y = 0.3;
  loosePencil.castShadow = true;
  scene.add(loosePencil);
  // Tip
  const looseTipMat = new THREE.MeshStandardMaterial({ color: 0xdec9a0, roughness: 0.5, metalness: 0.05 });
  const looseTip = new THREE.Mesh(new THREE.ConeGeometry(0.005, 0.015, 6), looseTipMat);
  looseTip.position.y = 0.08 + 0.007;
  loosePencil.add(looseTip);

  // --- Small sticky note pad (near pencil cup) ---
  const stickyX = cupX + 0.1, stickyZ = cupZ + 0.04;
  const stickyMat = new THREE.MeshStandardMaterial({ color: 0xfff176, roughness: 0.8, metalness: 0.0 });
  const stickyPad = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.015, 0.08), stickyMat);
  stickyPad.position.set(stickyX, globeSurfY + 0.0075, stickyZ);
  stickyPad.rotation.y = 0.2;
  stickyPad.castShadow = true;
  scene.add(stickyPad);

  // --- Desk Chair (in front of center monitor) ---
  const chairGroup = new THREE.Group();
  const chairX = -0.5, chairZ = backDeskZ + deskD / 2 + 0.7;
  const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1e, roughness: 0.6, metalness: 0.3 });
  const chairFabric = new THREE.MeshStandardMaterial({ color: 0x2a2a30, roughness: 0.85, metalness: 0.05 });
  const chairChromeMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.2, metalness: 0.8 });

  // --- Base star (5-spoke, radiating from center to each wheel) ---
  const spokeCount = 5;
  const spokeLen = 0.32, spokeR = 0.02;
  const baseY = 0.04;
  for (let i = 0; i < spokeCount; i++) {
    const angle = (i / spokeCount) * Math.PI * 2;
    const dx = Math.sin(angle);
    const dz = Math.cos(angle);

    // Spoke arm — cylinder stretched from hub center toward wheel
    const spokeGeo = new THREE.CylinderGeometry(spokeR, spokeR, spokeLen, 6);
    // Cylinder is vertical by default (Y-axis). Rotate to lay flat along Z, then rotate around Y to aim outward.
    const spoke = new THREE.Mesh(spokeGeo, chairChromeMat);
    spoke.position.set(dx * spokeLen / 2, baseY, dz * spokeLen / 2);
    // Point the cylinder from center toward (dx, 0, dz):
    // Default cylinder axis = Y. We want it along (dx, 0, dz).
    // Tilt from Y toward XZ plane (rotate around the perpendicular axis).
    spoke.rotation.order = 'YXZ';
    spoke.rotation.y = Math.atan2(dx, dz);
    spoke.rotation.x = Math.PI / 2;
    spoke.castShadow = true;
    chairGroup.add(spoke);

    // Caster wheel at end of each spoke
    const wheel = new THREE.Mesh(
      new THREE.SphereGeometry(0.025, 8, 8),
      chairMat
    );
    wheel.position.set(dx * spokeLen, 0.025, dz * spokeLen);
    chairGroup.add(wheel);
  }

  // --- Center hub (where spokes meet) ---
  const hub = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
    chairChromeMat
  );
  hub.position.set(0, 0.04, 0);
  chairGroup.add(hub);

  // --- Pneumatic cylinder ---
  const cylH = 0.32;
  const cylinder = new THREE.Mesh(
    new THREE.CylinderGeometry(0.025, 0.03, cylH, 12),
    chairChromeMat
  );
  cylinder.position.set(0, 0.04 + cylH / 2, 0);
  cylinder.castShadow = true;
  chairGroup.add(cylinder);

  // --- Seat ---
  const seatY = 0.04 + cylH + 0.03;
  const seatW = 0.5, seatD = 0.48, seatH = 0.07;

  // Seat cushion — rounded extrude
  const seatShape = roundedRectShape(seatW, seatD, 0.08);
  const seatGeo = new THREE.ExtrudeGeometry(seatShape, {
    depth: seatH,
    bevelEnabled: true,
    bevelThickness: 0.02,
    bevelSize: 0.02,
    bevelSegments: 4,
    curveSegments: 8,
  });
  const seat = new THREE.Mesh(seatGeo, chairFabric);
  seat.rotation.x = -Math.PI / 2;
  seat.position.set(0, seatY, 0);
  seat.castShadow = true; seat.receiveShadow = true;
  chairGroup.add(seat);

  // --- Backrest ---
  const chBackW = 0.46, chBackH = 0.5, chBackD = 0.06;
  const chBackY = seatY + 0.04;

  // Backrest support bracket — short metal piece connecting seat to back
  const chBracketGeo = new THREE.BoxGeometry(0.06, 0.1, 0.04);
  const chBracket = new THREE.Mesh(chBracketGeo, chairChromeMat);
  chBracket.position.set(0, chBackY + 0.02, seatD / 2 - 0.04);
  chBracket.castShadow = true;
  chairGroup.add(chBracket);

  // Backrest cushion
  const chBackShape = roundedRectShape(chBackW, chBackH, 0.06);
  const chBackGeo = new THREE.ExtrudeGeometry(chBackShape, {
    depth: chBackD,
    bevelEnabled: true,
    bevelThickness: 0.02,
    bevelSize: 0.02,
    bevelSegments: 4,
    curveSegments: 8,
  });
  const chBack = new THREE.Mesh(chBackGeo, chairFabric);
  chBack.position.set(0, chBackY + chBackH / 2 + 0.06, seatD / 2 - 0.02);
  chBack.rotation.x = -0.08;  // slight recline
  chBack.castShadow = true; chBack.receiveShadow = true;
  chairGroup.add(chBack);

  // --- Armrests ---
  [-1, 1].forEach(side => {
    const armX = side * (seatW / 2 + 0.01);

    // Arm support (vertical post from seat)
    const armPost = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.18, 0.03),
      chairMat
    );
    armPost.position.set(armX, seatY + 0.12, 0.02);
    armPost.castShadow = true;
    chairGroup.add(armPost);

    // Arm pad (horizontal)
    const armPad = new THREE.Mesh(
      new THREE.BoxGeometry(0.06, 0.025, 0.22),
      chairFabric
    );
    armPad.position.set(armX, seatY + 0.22, 0.0);
    armPad.castShadow = true; armPad.receiveShadow = true;
    chairGroup.add(armPad);
  });

  chairGroup.position.set(chairX, 0, chairZ);
  chairGroup.rotation.y = Math.PI + 0.4;  // face the desk, angled to the right
  chairGroup.castShadow = true;
  scene.add(chairGroup);

  // --- Bookshelf (right wall, solid front half) ---
  const bsX = HALF - 0.18;     // flush against right wall
  const bsW = 0.35;            // depth (into room)
  const bsH = ROOM_HEIGHT - 0.5; // nearly floor to ceiling
  const bsL = HALF - 0.8;      // length along the wall (z: 0.3 to HALF-0.5)
  const bsZ = HALF / 2 + 0.15; // centered on solid section
  const shelfCount = 5;
  const shelfThick = 0.04;

  const bsFrameMat = new THREE.MeshStandardMaterial({ color: 0x3B2314, roughness: 0.8, metalness: 0.05 });
  const bsShelfMat = new THREE.MeshStandardMaterial({ color: 0x4A2E1A, roughness: 0.75, metalness: 0.05 });

  // Back panel
  const bsBack = new THREE.Mesh(new THREE.BoxGeometry(0.03, bsH, bsL), bsFrameMat);
  bsBack.position.set(bsX, bsH / 2, bsZ);
  bsBack.castShadow = true; bsBack.receiveShadow = true;
  scene.add(bsBack);

  // Side panels (top and bottom along Z)
  [-1, 1].forEach(s => {
    const side = new THREE.Mesh(new THREE.BoxGeometry(bsW, bsH, 0.04), bsFrameMat);
    side.position.set(bsX - bsW / 2, bsH / 2, bsZ + s * (bsL / 2));
    side.castShadow = true; side.receiveShadow = true;
    scene.add(side);
  });

  // Top panel
  const bsTop = new THREE.Mesh(new THREE.BoxGeometry(bsW, shelfThick, bsL), bsFrameMat);
  bsTop.position.set(bsX - bsW / 2, bsH, bsZ);
  bsTop.castShadow = true; bsTop.receiveShadow = true;
  scene.add(bsTop);

  // Shelves + books
  const bookColors = [
    0x8B1A1A, 0x1A3C8B, 0x2E6B2E, 0x8B6B1A, 0x6B1A6B,
    0x1A6B6B, 0x8B4513, 0x2F4F4F, 0x800020, 0x1B4D3E,
    0x4A3728, 0x2C3E50, 0x7B3F00, 0x3B0A30, 0x1C3A1C,
  ];

  for (let i = 0; i <= shelfCount; i++) {
    const shelfY = (i / shelfCount) * (bsH - 0.1) + 0.05;

    // Shelf plank
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(bsW, shelfThick, bsL), bsShelfMat);
    shelf.position.set(bsX - bsW / 2, shelfY, bsZ);
    shelf.castShadow = true; shelf.receiveShadow = true;
    scene.add(shelf);

    // Books on this shelf (skip the top shelf)
    if (i < shelfCount) {
      const slotH = (bsH - 0.1) / shelfCount - shelfThick;
      let z = bsZ - bsL / 2 + 0.06;

      while (z < bsZ + bsL / 2 - 0.06) {
        // Random gap / empty space
        if (Math.random() < 0.12) {
          z += 0.06 + Math.random() * 0.1;
          continue;
        }

        // Occasionally lay a book flat (horizontal stack)
        const layFlat = Math.random() < 0.1;

        const bookW = 0.03 + Math.random() * 0.055;
        const bookH = layFlat ? 0.03 + Math.random() * 0.02 : slotH * (0.45 + Math.random() * 0.52);
        const bookD = bsW * (0.5 + Math.random() * 0.45);
        const colorIdx = Math.floor(Math.random() * bookColors.length);
        const bookMat = new THREE.MeshStandardMaterial({
          color: bookColors[colorIdx],
          roughness: 0.7 + Math.random() * 0.25,
          metalness: Math.random() * 0.05,
        });
        const book = new THREE.Mesh(new THREE.BoxGeometry(bookD, bookH, bookW), bookMat);

        if (layFlat) {
          // Stack 1-3 flat books
          const stackCount = 1 + Math.floor(Math.random() * 3);
          let stackY = shelfY + shelfThick / 2;
          const stackZ = z + 0.05;
          for (let s = 0; s < stackCount; s++) {
            const fBookW = 0.08 + Math.random() * 0.06;
            const fBookH = 0.02 + Math.random() * 0.015;
            const fBookD = bsW * (0.55 + Math.random() * 0.35);
            const fColorIdx = Math.floor(Math.random() * bookColors.length);
            const fMat = new THREE.MeshStandardMaterial({
              color: bookColors[fColorIdx],
              roughness: 0.7 + Math.random() * 0.25,
              metalness: Math.random() * 0.05,
            });
            const fBook = new THREE.Mesh(new THREE.BoxGeometry(fBookD, fBookH, fBookW), fMat);
            fBook.position.set(
              bsX - bsW / 2 + fBookD / 2 * (0.8 + Math.random() * 0.2),
              stackY + fBookH / 2,
              stackZ
            );
            fBook.rotation.y = (Math.random() - 0.5) * 0.15;
            fBook.castShadow = true; fBook.receiveShadow = true;
            scene.add(fBook);
            stackY += fBookH;
          }
          z += 0.12 + Math.random() * 0.05;
        } else {
          book.position.set(
            bsX - bsW / 2 + (bookD / 2) * (0.75 + Math.random() * 0.25),
            shelfY + shelfThick / 2 + bookH / 2,
            z + bookW / 2
          );
          // More varied tilt — some books lean noticeably
          const tilt = Math.random();
          if (tilt < 0.15) {
            book.rotation.z = (Math.random() - 0.5) * 0.35;
          } else if (tilt < 0.4) {
            book.rotation.z = (Math.random() - 0.5) * 0.15;
          } else {
            book.rotation.z = (Math.random() - 0.5) * 0.04;
          }
          book.rotation.y = (Math.random() - 0.5) * 0.08;
          book.castShadow = true; book.receiveShadow = true;
          scene.add(book);
          z += bookW + 0.003 + Math.random() * 0.015;
        }
      }
    }
  }

  // --- Light Blue Couch (front wall, opposite main window) ---
  // Helper: rounded rectangle shape for cushion extrusions
  function roundedRectShape(w, h, r) {
    const s = new THREE.Shape();
    s.moveTo(-w / 2 + r, -h / 2);
    s.lineTo(w / 2 - r, -h / 2);
    s.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + r);
    s.lineTo(w / 2, h / 2 - r);
    s.quadraticCurveTo(w / 2, h / 2, w / 2 - r, h / 2);
    s.lineTo(-w / 2 + r, h / 2);
    s.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - r);
    s.lineTo(-w / 2, -h / 2 + r);
    s.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + r, -h / 2);
    return s;
  }

  const couchZ = HALF - 0.55;   // near front wall
  const couchX = 0;             // centered
  const couchSeatH = 0.33;      // seat height from floor

  const couchFabric = new THREE.MeshStandardMaterial({ color: 0x7EB4D2, roughness: 0.92, metalness: 0.0 });
  const couchFabricDark = new THREE.MeshStandardMaterial({ color: 0x6A9DBB, roughness: 0.92, metalness: 0.0 });
  const couchLegMat = new THREE.MeshStandardMaterial({ color: 0x3B2314, roughness: 0.7, metalness: 0.1 });

  const extrudeOpts = (depth) => ({
    depth,
    bevelEnabled: true,
    bevelThickness: 0.03,
    bevelSize: 0.03,
    bevelSegments: 4,
    curveSegments: 8,
  });

  // --- Base / frame (hidden, under cushions) ---
  const baseShape = roundedRectShape(2.6, 0.85, 0.08);
  const baseGeo = new THREE.ExtrudeGeometry(baseShape, extrudeOpts(0.12));
  const base = new THREE.Mesh(baseGeo, couchFabricDark);
  base.rotation.x = -Math.PI / 2;
  base.position.set(couchX, 0.18, couchZ);
  base.castShadow = true; base.receiveShadow = true;
  scene.add(base);

  // --- Seat cushions (3 side by side) ---
  for (let ci = -1; ci <= 1; ci++) {
    const cushShape = roundedRectShape(0.82, 0.75, 0.1);
    const cushGeo = new THREE.ExtrudeGeometry(cushShape, extrudeOpts(0.14));
    const cush = new THREE.Mesh(cushGeo, couchFabric);
    cush.rotation.x = -Math.PI / 2;
    cush.position.set(couchX + ci * 0.86, couchSeatH, couchZ);
    cush.castShadow = true; cush.receiveShadow = true;
    scene.add(cush);
  }

  // --- Back cushion (one long pillow, slightly tilted back) ---
  const backShape = roundedRectShape(2.5, 1.0, 0.12);
  const backGeo = new THREE.ExtrudeGeometry(backShape, extrudeOpts(0.16));
  const backCush = new THREE.Mesh(backGeo, couchFabric);
  backCush.rotation.x = 0;
  backCush.position.set(couchX, couchSeatH + 0.22, couchZ + 0.3);
  backCush.castShadow = true; backCush.receiveShadow = true;
  scene.add(backCush);

  // --- Small red throw pillow (left corner of couch) ---
  const pillowMat = new THREE.MeshStandardMaterial({ color: 0xB83233, roughness: 0.92, metalness: 0.0 });
  const pillowShape = roundedRectShape(0.32, 0.32, 0.1);
  const pillowGeo = new THREE.ExtrudeGeometry(pillowShape, {
    depth: 0.12,
    bevelEnabled: true,
    bevelThickness: 0.04,
    bevelSize: 0.04,
    bevelSegments: 6,
    curveSegments: 10,
  });
  const pillow = new THREE.Mesh(pillowGeo, pillowMat);
  pillow.position.set(couchX - 1.05, couchSeatH + 0.35, couchZ + 0.15);
  pillow.rotation.x = 0.25;
  pillow.rotation.y = 0.2;
  pillow.rotation.z = 0.1;
  pillow.castShadow = true; pillow.receiveShadow = true;
  scene.add(pillow);

  // --- Armrests (rounded cylinders with spherical caps) ---
  [-1, 1].forEach(side => {
    const armX = couchX + side * 1.4;

    // Main arm body — rounded horizontal cylinder
    const armGeo = new THREE.CylinderGeometry(0.16, 0.18, 0.8, 16, 1, false);
    const arm = new THREE.Mesh(armGeo, couchFabricDark);
    arm.rotation.z = Math.PI / 2;
    arm.rotation.y = Math.PI / 2;
    arm.position.set(armX, couchSeatH + 0.12, couchZ);
    arm.castShadow = true; arm.receiveShadow = true;
    scene.add(arm);

    // Front cap — sphere for softness
    const capGeo = new THREE.SphereGeometry(0.16, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
    const capFront = new THREE.Mesh(capGeo, couchFabricDark);
    capFront.rotation.x = Math.PI / 2;
    capFront.position.set(armX, couchSeatH + 0.12, couchZ - 0.4);
    capFront.castShadow = true;
    scene.add(capFront);

    // Back cap
    const capBack = new THREE.Mesh(capGeo, couchFabricDark);
    capBack.rotation.x = -Math.PI / 2;
    capBack.position.set(armX, couchSeatH + 0.12, couchZ + 0.4);
    capBack.castShadow = true;
    scene.add(capBack);

    // Arm inner support (fills gap between arm and seat)
    const supportShape = roundedRectShape(0.28, 0.75, 0.06);
    const supportGeo = new THREE.ExtrudeGeometry(supportShape, extrudeOpts(couchSeatH - 0.05));
    const support = new THREE.Mesh(supportGeo, couchFabricDark);
    support.rotation.x = -Math.PI / 2;
    support.position.set(armX, 0.05, couchZ);
    support.castShadow = true; support.receiveShadow = true;
    scene.add(support);
  });

  // --- Wooden legs (short, rounded) ---
  const couchLegR = 0.04;
  const couchLegH = 0.08;
  [[-1.25, -0.32], [-1.25, 0.32], [1.25, -0.32], [1.25, 0.32]].forEach(([lx, lz]) => {
    const cLegGeo = new THREE.CylinderGeometry(couchLegR, couchLegR * 1.2, couchLegH, 10);
    const leg = new THREE.Mesh(cLegGeo, couchLegMat);
    leg.position.set(couchX + lx, couchLegH / 2, couchZ + lz);
    leg.castShadow = true;
    scene.add(leg);
  });

  // --- Persian Maroon Rug (in front of couch) ---
  const rugW = 4.0, rugD = 3.0;
  const rugCanvas = document.createElement('canvas');
  rugCanvas.width = 512; rugCanvas.height = 512;
  const rctx = rugCanvas.getContext('2d');

  // Base maroon
  rctx.fillStyle = '#5C1A1A';
  rctx.fillRect(0, 0, 512, 512);

  // Outer border
  rctx.strokeStyle = '#8B6B3E';
  rctx.lineWidth = 18;
  rctx.strokeRect(20, 20, 472, 472);
  rctx.strokeStyle = '#3B0E0E';
  rctx.lineWidth = 6;
  rctx.strokeRect(36, 36, 440, 440);
  rctx.strokeStyle = '#8B6B3E';
  rctx.lineWidth = 3;
  rctx.strokeRect(44, 44, 424, 424);

  // Inner field — slightly different maroon
  rctx.fillStyle = '#4E1616';
  rctx.fillRect(52, 52, 408, 408);

  // Central medallion
  rctx.save();
  rctx.translate(256, 256);
  // Outer diamond
  rctx.fillStyle = '#7A2E2E';
  rctx.beginPath();
  rctx.moveTo(0, -100); rctx.lineTo(80, 0); rctx.lineTo(0, 100); rctx.lineTo(-80, 0);
  rctx.closePath();
  rctx.fill();
  rctx.strokeStyle = '#8B6B3E';
  rctx.lineWidth = 2;
  rctx.stroke();
  // Inner diamond
  rctx.fillStyle = '#3B0E0E';
  rctx.beginPath();
  rctx.moveTo(0, -60); rctx.lineTo(48, 0); rctx.lineTo(0, 60); rctx.lineTo(-48, 0);
  rctx.closePath();
  rctx.fill();
  rctx.strokeStyle = '#A8844A';
  rctx.lineWidth = 1.5;
  rctx.stroke();
  // Center motif
  rctx.fillStyle = '#8B6B3E';
  rctx.beginPath();
  rctx.arc(0, 0, 12, 0, Math.PI * 2);
  rctx.fill();
  rctx.restore();

  // Corner motifs
  [[90, 90], [422, 90], [90, 422], [422, 422]].forEach(([cx, cy]) => {
    rctx.save();
    rctx.translate(cx, cy);
    rctx.fillStyle = '#7A2E2E';
    rctx.beginPath();
    rctx.moveTo(0, -35); rctx.lineTo(28, 0); rctx.lineTo(0, 35); rctx.lineTo(-28, 0);
    rctx.closePath();
    rctx.fill();
    rctx.strokeStyle = '#8B6B3E';
    rctx.lineWidth = 1.5;
    rctx.stroke();
    rctx.fillStyle = '#A8844A';
    rctx.beginPath();
    rctx.arc(0, 0, 6, 0, Math.PI * 2);
    rctx.fill();
    rctx.restore();
  });

  // Repeating border motifs along edges
  for (let i = 0; i < 8; i++) {
    const t = 76 + i * 50;
    // Top/bottom
    rctx.fillStyle = '#A8844A';
    rctx.fillRect(t, 24, 8, 8);
    rctx.fillRect(t, 480, 8, 8);
    // Left/right
    rctx.fillRect(24, t, 8, 8);
    rctx.fillRect(480, t, 8, 8);
  }

  // Fuzzy noise overlay for texture
  const imgData = rctx.getImageData(0, 0, 512, 512);
  const d = imgData.data;
  for (let p = 0; p < d.length; p += 4) {
    const noise = (Math.random() - 0.5) * 30;
    d[p] = Math.max(0, Math.min(255, d[p] + noise));
    d[p + 1] = Math.max(0, Math.min(255, d[p + 1] + noise));
    d[p + 2] = Math.max(0, Math.min(255, d[p + 2] + noise));
  }
  rctx.putImageData(imgData, 0, 0);

  const rugTex = new THREE.CanvasTexture(rugCanvas);
  const rugMat = new THREE.MeshStandardMaterial({
    map: rugTex,
    roughness: 1.0,
    metalness: 0.0,
    side: THREE.DoubleSide,
  });

  // Rug mesh — very thin box with subdivided top for fuzz displacement
  const rugGeo = new THREE.PlaneGeometry(rugW, rugD, 80, 80);
  // Displace vertices slightly for fuzzy surface
  const rugPos = rugGeo.attributes.position;
  for (let v = 0; v < rugPos.count; v++) {
    rugPos.setZ(v, rugPos.getZ(v) + (Math.random() - 0.3) * 0.008);
  }
  rugPos.needsUpdate = true;
  rugGeo.computeVertexNormals();

  const rug = new THREE.Mesh(rugGeo, rugMat);
  rug.rotation.x = -Math.PI / 2;
  rug.position.set(couchX, 0.005, couchZ - 2.0);
  rug.receiveShadow = true;
  scene.add(rug);

  // --- Rug side binding (raised edges along long sides) ---
  const bindingMat = new THREE.MeshStandardMaterial({ color: 0x8B6B3E, roughness: 0.9, metalness: 0.0 });
  const rugCX = couchX, rugCZ = couchZ - 2.0;
  [-1, 1].forEach(side => {
    const bindGeo = new THREE.CylinderGeometry(0.015, 0.015, rugW, 8);
    const bind = new THREE.Mesh(bindGeo, bindingMat);
    bind.rotation.z = Math.PI / 2;
    bind.position.set(rugCX, 0.012, rugCZ + side * rugD / 2);
    bind.receiveShadow = true;
    scene.add(bind);
  });
  // Binding along short sides
  [-1, 1].forEach(side => {
    const bindGeo = new THREE.CylinderGeometry(0.015, 0.015, rugD, 8);
    const bind = new THREE.Mesh(bindGeo, bindingMat);
    bind.rotation.x = Math.PI / 2;
    bind.position.set(rugCX + side * rugW / 2, 0.012, rugCZ);
    bind.receiveShadow = true;
    scene.add(bind);
  });

  // --- Rug fringe (short ends, along the Z-axis edges) ---
  const fringeMat = new THREE.MeshStandardMaterial({ color: 0xC9B077, roughness: 1.0, metalness: 0.0 });
  [-1, 1].forEach(side => {
    const fringeZ = rugCZ + side * (rugD / 2 + 0.005);
    const fringeCount = 60;
    for (let f = 0; f < fringeCount; f++) {
      const fx = rugCX - rugW / 2 + 0.04 + f * ((rugW - 0.08) / (fringeCount - 1));
      const fLen = 0.06 + Math.random() * 0.04;
      const fThick = 0.004 + Math.random() * 0.003;
      const fGeo = new THREE.CylinderGeometry(fThick, fThick * 0.5, fLen, 4);
      const strand = new THREE.Mesh(fGeo, fringeMat);
      // Lay flat on the ground, pointing away from the rug
      strand.rotation.x = side * (Math.PI / 2 + (Math.random() - 0.5) * 0.3);
      strand.rotation.z = (Math.random() - 0.5) * 0.2;
      strand.position.set(
        fx + (Math.random() - 0.5) * 0.01,
        0.005,
        fringeZ + side * fLen / 2
      );
      strand.receiveShadow = true;
      scene.add(strand);
    }
  });

  // --- Wooden Nightstand (front-right corner, opposite windows) ---
  const nsX = HALF - 0.45, nsZ = HALF - 0.45;
  const nsW = 0.5, nsD = 0.5, nsH = 0.55;
  const nsThick = 0.04;

  // Wood material
  const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B5E3C, roughness: 0.75, metalness: 0.05 });
  const woodDarkMat = new THREE.MeshStandardMaterial({ color: 0x6B4226, roughness: 0.8, metalness: 0.05 });

  // Tabletop
  const nsTop = new THREE.Mesh(new THREE.BoxGeometry(nsW, nsThick, nsD), woodMat);
  nsTop.position.set(nsX, nsH, nsZ);
  nsTop.castShadow = true; nsTop.receiveShadow = true;
  scene.add(nsTop);

  // Four legs
  const legH = nsH - nsThick / 2;
  const legThick = 0.05;
  const legGeo = new THREE.BoxGeometry(legThick, legH, legThick);
  [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([sx, sz]) => {
    const leg = new THREE.Mesh(legGeo, woodDarkMat);
    leg.position.set(
      nsX + sx * (nsW / 2 - legThick / 2),
      legH / 2,
      nsZ + sz * (nsD / 2 - legThick / 2)
    );
    leg.castShadow = true; leg.receiveShadow = true;
    scene.add(leg);
  });

  // Bottom shelf
  const shelfY = 0.12;
  const nsShelf = new THREE.Mesh(new THREE.BoxGeometry(nsW - 0.06, nsThick * 0.7, nsD - 0.06), woodMat);
  nsShelf.position.set(nsX, shelfY, nsZ);
  nsShelf.castShadow = true; nsShelf.receiveShadow = true;
  scene.add(nsShelf);

  // --- Cozy Orange Lamp (on top of nightstand) ---
  const lampBaseY = nsH + nsThick / 2;

  // Lamp base — small dark wood disc
  const lampBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.08, 0.025, 20),
    woodDarkMat
  );
  lampBase.position.set(nsX, lampBaseY + 0.0125, nsZ);
  lampBase.castShadow = true;
  scene.add(lampBase);

  // Lamp pole — thin brass-ish stem
  const poleMat = new THREE.MeshStandardMaterial({ color: 0xAA8844, roughness: 0.35, metalness: 0.6 });
  const lampPole = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.25, 10), poleMat);
  lampPole.position.set(nsX, lampBaseY + 0.15, nsZ);
  lampPole.castShadow = true;
  scene.add(lampPole);

  // Neon bulb — hot emissive sphere (no shade)
  const lampBulbMat = new THREE.MeshStandardMaterial({
    color: 0xFF6600,
    emissive: 0xFF6600,
    emissiveIntensity: 3.0,
    roughness: 0.05,
    metalness: 0.8,
  });
  const lampBulb = new THREE.Mesh(new THREE.SphereGeometry(0.06, 24, 24), lampBulbMat);
  lampBulb.position.set(nsX, lampBaseY + 0.34, nsZ);
  scene.add(lampBulb);

  // Neon glow layers — stacked transparent spheres for bloom
  [
    { radius: 0.10, color: 0xFFAA44, opacity: 0.4 },
    { radius: 0.20, color: 0xFF6600, opacity: 0.2 },
    { radius: 0.38, color: 0xFF5500, opacity: 0.09 },
    { radius: 0.65, color: 0xFF4400, opacity: 0.035 },
    { radius: 1.0,  color: 0xFF3300, opacity: 0.015 },
  ].forEach(g => {
    const mat = new THREE.MeshBasicMaterial({ color: g.color, transparent: true, opacity: g.opacity, depthWrite: false });
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(g.radius, 24, 24), mat);
    mesh.position.set(nsX, lampBaseY + 0.34, nsZ);
    scene.add(mesh);
  });

  // Primary neon point light — intense
  const orangeLight = new THREE.PointLight(0xFF5500, 1.8, 10, 1.5);
  orangeLight.position.set(nsX, lampBaseY + 0.34, nsZ);
  orangeLight.castShadow = false;
  scene.add(orangeLight);

  // Secondary fill — wider neon wash
  const orangeFill = new THREE.PointLight(0xFF4400, 0.6, 16, 2);
  orangeFill.position.set(nsX, lampBaseY + 0.34, nsZ);
  scene.add(orangeFill);

  // --- Player Controls ---
  const keys = {};
  let yaw = 0, pitch = 0;
  let locked = false;
  const SPEED = 4;
  const SPRINT_MULT = 1.8;
  const SENSITIVITY = 0.002;
  const PLAYER_RADIUS = 0.4;
  const EYE_HEIGHT = 1.7;
  const BOUND = HALF - PLAYER_RADIUS;

  // Head bob
  let bobTime = 0;
  const BOB_SPEED = 10;
  const BOB_AMOUNT = 0.04;

  document.addEventListener('keydown', e => keys[e.code] = true);
  document.addEventListener('keyup', e => keys[e.code] = false);

  let needsRender = true;  // flag for idle throttling
  document.addEventListener('mousemove', e => {
    if (!locked) return;
    yaw -= e.movementX * SENSITIVITY;
    pitch -= e.movementY * SENSITIVITY;
    pitch = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, pitch));
    needsRender = true;
  });

  // Pointer lock
  const overlay = document.getElementById('overlay');
  const crosshair = document.getElementById('crosshair');
  const info = document.getElementById('info');

  let enteredTime = null;
  overlay.addEventListener('click', () => {
    if (!enteredTime) enteredTime = performance.now();
    renderer.domElement.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', () => {
    locked = document.pointerLockElement === renderer.domElement;
    const anyModalOpen = aboutOpen || cvOpen || pubOpen || linkedinOpen || githubOpen;
    overlay.style.display = locked || anyModalOpen ? 'none' : 'flex';
    crosshair.style.display = locked ? 'block' : 'none';
    info.style.display = locked ? 'block' : 'none';
  });

  // --- Raycaster for interactive monitors ---
  const raycaster = new THREE.Raycaster();
  const screenCenter = new THREE.Vector2(0, 0);
  let hoveringRight = false;
  let hoveringCenter = false;
  let hoveringLeft = false;
  let hoveringCV = false;
  let hoveringPub = false;
  const aboutModal = document.getElementById('about-modal');
  const cvModal = document.getElementById('cv-modal');
  const pubModal = document.getElementById('pub-modal');
  const linkedinModal = document.getElementById('linkedin-modal');
  const githubModal = document.getElementById('github-modal');
  const modalBackdrop = document.getElementById('modal-backdrop');
  let aboutOpen = false;
  let cvOpen = false;
  let pubOpen = false;
  let linkedinOpen = false;
  let githubOpen = false;

  function showBackdrop() { modalBackdrop.style.display = 'block'; }
  function hideBackdrop() { modalBackdrop.style.display = 'none'; }

  document.addEventListener('click', (e) => {
    if (aboutOpen) {
      aboutModal.style.display = 'none';
      hideBackdrop();
      aboutOpen = false;
      renderer.domElement.requestPointerLock();
      return;
    }
    if (cvOpen) {
      if (e.target.closest('.modal-link')) return;
      cvModal.style.display = 'none';
      hideBackdrop();
      cvOpen = false;
      renderer.domElement.requestPointerLock();
      return;
    }
    if (pubOpen) {
      if (e.target.closest('.modal-link')) return;
      pubModal.style.display = 'none';
      hideBackdrop();
      pubOpen = false;
      renderer.domElement.requestPointerLock();
      return;
    }
    if (linkedinOpen) {
      if (e.target.closest('.modal-link')) return; // let the link navigate
      linkedinModal.style.display = 'none';
      hideBackdrop();
      linkedinOpen = false;
      renderer.domElement.requestPointerLock();
      return;
    }
    if (githubOpen) {
      if (e.target.closest('.modal-link')) return; // let the link navigate
      githubModal.style.display = 'none';
      hideBackdrop();
      githubOpen = false;
      renderer.domElement.requestPointerLock();
      return;
    }
    if (locked && hoveringRight) {
      document.exitPointerLock();
      showBackdrop();
      githubModal.style.display = 'block';
      githubOpen = true;
    }
    if (locked && hoveringLeft) {
      document.exitPointerLock();
      showBackdrop();
      linkedinModal.style.display = 'block';
      linkedinOpen = true;
    }
    if (locked && hoveringCenter) {
      document.exitPointerLock();
      showBackdrop();
      aboutModal.style.display = 'block';
      aboutOpen = true;
    }
    if (locked && hoveringCV) {
      document.exitPointerLock();
      showBackdrop();
      cvModal.style.display = 'block';
      cvOpen = true;
    }
    if (locked && hoveringPub) {
      document.exitPointerLock();
      showBackdrop();
      pubModal.style.display = 'block';
      pubOpen = true;
    }
  });

  // Footstep audio context (subtle)
  let audioCtx;
  let lastStepTime = 0;

  function playStep() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 60 + Math.random() * 30;
    gain.gain.setValueAtTime(0.03, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.12);
  }

  // --- Game Loop ---
  const clock = new THREE.Clock();
  let lastRenderTime = 0;
  const IDLE_INTERVAL = 1 / 10;  // 10 FPS when idle

  function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);

    if (locked) {
      const sprint = keys['ShiftLeft'] || keys['ShiftRight'] ? SPRINT_MULT : 1;
      const speed = SPEED * sprint * dt;

      const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

      let moving = false;
      const move = new THREE.Vector3();

      if (keys['KeyW'] || keys['ArrowUp']) { move.add(forward); moving = true; }
      if (keys['KeyS'] || keys['ArrowDown']) { move.sub(forward); moving = true; }
      if (keys['KeyD'] || keys['ArrowRight']) { move.add(right); moving = true; }
      if (keys['KeyA'] || keys['ArrowLeft']) { move.sub(right); moving = true; }

      if (moving) {
        needsRender = true;
        move.normalize().multiplyScalar(speed);
        camera.position.x = Math.max(-BOUND, Math.min(BOUND, camera.position.x + move.x));
        camera.position.z = Math.max(-BOUND, Math.min(BOUND, camera.position.z + move.z));

        // Head bob
        bobTime += dt * BOB_SPEED * sprint;
        camera.position.y = EYE_HEIGHT + Math.sin(bobTime) * BOB_AMOUNT;

        // Footstep sounds
        const stepInterval = sprint > 1 ? 0.3 : 0.5;
        if (clock.elapsedTime - lastStepTime > stepInterval) {
          playStep();
          lastStepTime = clock.elapsedTime;
        }
      } else {
        // Smoothly return to eye height
        camera.position.y += (EYE_HEIGHT - camera.position.y) * 0.1;
      }

      // Apply rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;

      // Raycast for interactive monitors
      raycaster.setFromCamera(screenCenter, camera);
      const rHits = raycaster.intersectObjects(rMonGroup.children, true);
      hoveringRight = rHits.length > 0 && rHits[0].distance < 3;
      const cHits = raycaster.intersectObjects(monGroup.children, true);
      hoveringCenter = cHits.length > 0 && cHits[0].distance < 3;
      const lHits = raycaster.intersectObjects(lMonGroup.children, true);
      hoveringLeft = lHits.length > 0 && lHits[0].distance < 3;
      const cvHits = raycaster.intersectObject(paperMeshes[0], true);
      hoveringCV = cvHits.length > 0 && cvHits[0].distance < 3;
      const pubHits = raycaster.intersectObject(paperMeshes[1], true);
      hoveringPub = pubHits.length > 0 && pubHits[0].distance < 3;
      crosshair.classList.toggle('hover-green', hoveringRight);
      crosshair.classList.toggle('hover-pink', hoveringLeft);
      crosshair.classList.toggle('hover-blue', hoveringCenter);
      crosshair.classList.toggle('hover-paper', hoveringCV || hoveringPub);
    }

    // Neon sign flicker — dying neon effect, stops after 2s
    const t = clock.elapsedTime;
    const sinceEntry = enteredTime ? (performance.now() - enteredTime) / 1000 : 0;
    const flickering = !enteredTime || sinceEntry < 2;
    let neonBrightness = 1.0;
    if (flickering) {
      needsRender = true;  // always render during flicker
      const flick = Math.sin(t * 23.7) * Math.sin(t * 7.3) + Math.sin(t * 53.1) * 0.5;
      if (flick > 0.7) {
        neonBrightness = 0.05 + Math.random() * 0.1;
      } else if (flick > 0.4) {
        neonBrightness = 0.3 + Math.random() * 0.3;
      } else if (Math.random() < 0.02) {
        neonBrightness = 0.0;
      } else if (Math.random() < 0.05) {
        neonBrightness = 0.4 + Math.random() * 0.3;
      }
    }
    neonSignMat.opacity = neonBrightness;
    neonGlow.intensity = 0.6 * neonBrightness;
    neonFill.intensity = 0.2 * neonBrightness;

    // --- Idle throttle: skip render if nothing changed ---
    const now = performance.now() / 1000;
    if (!needsRender && (now - lastRenderTime) < IDLE_INTERVAL) return;
    needsRender = false;
    lastRenderTime = now;

    // --- Two-pass render: skybox first, then room on top ---
    // Pass 1: Render space skybox (rotation only — no position, so it's at infinity)
    spaceCamera.quaternion.copy(camera.quaternion);

    renderer.clear(true, true, true);
    renderer.render(spaceScene, spaceCamera);

    // Pass 2: Render the room on top. Clear only the depth buffer so
    // room geometry writes over the skybox, but the hole in the back wall
    // lets the skybox pixels show through.
    renderer.clearDepth();
    renderer.render(scene, camera);
  }

  animate();

  // --- Resize ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    spaceCamera.aspect = window.innerWidth / window.innerHeight;
    spaceCamera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>
